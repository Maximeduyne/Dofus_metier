
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Character
 * 
 */
export type Character = $Result.DefaultSelection<Prisma.$CharacterPayload>
/**
 * Model Job
 * 
 */
export type Job = $Result.DefaultSelection<Prisma.$JobPayload>
/**
 * Model JobActivity
 * 
 */
export type JobActivity = $Result.DefaultSelection<Prisma.$JobActivityPayload>
/**
 * Model Resource
 * 
 */
export type Resource = $Result.DefaultSelection<Prisma.$ResourcePayload>
/**
 * Model Recipe
 * 
 */
export type Recipe = $Result.DefaultSelection<Prisma.$RecipePayload>
/**
 * Model CraftInput
 * 
 */
export type CraftInput = $Result.DefaultSelection<Prisma.$CraftInputPayload>
/**
 * Model Pack
 * 
 */
export type Pack = $Result.DefaultSelection<Prisma.$PackPayload>
/**
 * Model PackItem
 * 
 */
export type PackItem = $Result.DefaultSelection<Prisma.$PackItemPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.character`: Exposes CRUD operations for the **Character** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Characters
    * const characters = await prisma.character.findMany()
    * ```
    */
  get character(): Prisma.CharacterDelegate<ExtArgs>;

  /**
   * `prisma.job`: Exposes CRUD operations for the **Job** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.job.findMany()
    * ```
    */
  get job(): Prisma.JobDelegate<ExtArgs>;

  /**
   * `prisma.jobActivity`: Exposes CRUD operations for the **JobActivity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobActivities
    * const jobActivities = await prisma.jobActivity.findMany()
    * ```
    */
  get jobActivity(): Prisma.JobActivityDelegate<ExtArgs>;

  /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<ExtArgs>;

  /**
   * `prisma.recipe`: Exposes CRUD operations for the **Recipe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recipes
    * const recipes = await prisma.recipe.findMany()
    * ```
    */
  get recipe(): Prisma.RecipeDelegate<ExtArgs>;

  /**
   * `prisma.craftInput`: Exposes CRUD operations for the **CraftInput** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CraftInputs
    * const craftInputs = await prisma.craftInput.findMany()
    * ```
    */
  get craftInput(): Prisma.CraftInputDelegate<ExtArgs>;

  /**
   * `prisma.pack`: Exposes CRUD operations for the **Pack** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Packs
    * const packs = await prisma.pack.findMany()
    * ```
    */
  get pack(): Prisma.PackDelegate<ExtArgs>;

  /**
   * `prisma.packItem`: Exposes CRUD operations for the **PackItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PackItems
    * const packItems = await prisma.packItem.findMany()
    * ```
    */
  get packItem(): Prisma.PackItemDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Character: 'Character',
    Job: 'Job',
    JobActivity: 'JobActivity',
    Resource: 'Resource',
    Recipe: 'Recipe',
    CraftInput: 'CraftInput',
    Pack: 'Pack',
    PackItem: 'PackItem'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "account" | "character" | "job" | "jobActivity" | "resource" | "recipe" | "craftInput" | "pack" | "packItem"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Character: {
        payload: Prisma.$CharacterPayload<ExtArgs>
        fields: Prisma.CharacterFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CharacterFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CharacterFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findFirst: {
            args: Prisma.CharacterFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CharacterFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          findMany: {
            args: Prisma.CharacterFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>[]
          }
          create: {
            args: Prisma.CharacterCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          createMany: {
            args: Prisma.CharacterCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CharacterDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          update: {
            args: Prisma.CharacterUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          deleteMany: {
            args: Prisma.CharacterDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CharacterUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CharacterUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CharacterPayload>
          }
          aggregate: {
            args: Prisma.CharacterAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCharacter>
          }
          groupBy: {
            args: Prisma.CharacterGroupByArgs<ExtArgs>
            result: $Utils.Optional<CharacterGroupByOutputType>[]
          }
          count: {
            args: Prisma.CharacterCountArgs<ExtArgs>
            result: $Utils.Optional<CharacterCountAggregateOutputType> | number
          }
        }
      }
      Job: {
        payload: Prisma.$JobPayload<ExtArgs>
        fields: Prisma.JobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findFirst: {
            args: Prisma.JobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          findMany: {
            args: Prisma.JobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>[]
          }
          create: {
            args: Prisma.JobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          createMany: {
            args: Prisma.JobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          update: {
            args: Prisma.JobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          deleteMany: {
            args: Prisma.JobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobPayload>
          }
          aggregate: {
            args: Prisma.JobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob>
          }
          groupBy: {
            args: Prisma.JobGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobCountArgs<ExtArgs>
            result: $Utils.Optional<JobCountAggregateOutputType> | number
          }
        }
      }
      JobActivity: {
        payload: Prisma.$JobActivityPayload<ExtArgs>
        fields: Prisma.JobActivityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JobActivityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JobActivityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>
          }
          findFirst: {
            args: Prisma.JobActivityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JobActivityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>
          }
          findMany: {
            args: Prisma.JobActivityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>[]
          }
          create: {
            args: Prisma.JobActivityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>
          }
          createMany: {
            args: Prisma.JobActivityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JobActivityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>
          }
          update: {
            args: Prisma.JobActivityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>
          }
          deleteMany: {
            args: Prisma.JobActivityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JobActivityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JobActivityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JobActivityPayload>
          }
          aggregate: {
            args: Prisma.JobActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobActivity>
          }
          groupBy: {
            args: Prisma.JobActivityGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.JobActivityCountArgs<ExtArgs>
            result: $Utils.Optional<JobActivityCountAggregateOutputType> | number
          }
        }
      }
      Resource: {
        payload: Prisma.$ResourcePayload<ExtArgs>
        fields: Prisma.ResourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findFirst: {
            args: Prisma.ResourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          findMany: {
            args: Prisma.ResourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>[]
          }
          create: {
            args: Prisma.ResourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          createMany: {
            args: Prisma.ResourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ResourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          update: {
            args: Prisma.ResourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          deleteMany: {
            args: Prisma.ResourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ResourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ResourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ResourcePayload>
          }
          aggregate: {
            args: Prisma.ResourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateResource>
          }
          groupBy: {
            args: Prisma.ResourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ResourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResourceCountArgs<ExtArgs>
            result: $Utils.Optional<ResourceCountAggregateOutputType> | number
          }
        }
      }
      Recipe: {
        payload: Prisma.$RecipePayload<ExtArgs>
        fields: Prisma.RecipeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RecipeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RecipeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findFirst: {
            args: Prisma.RecipeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RecipeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          findMany: {
            args: Prisma.RecipeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>[]
          }
          create: {
            args: Prisma.RecipeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          createMany: {
            args: Prisma.RecipeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RecipeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          update: {
            args: Prisma.RecipeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          deleteMany: {
            args: Prisma.RecipeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RecipeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RecipeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RecipePayload>
          }
          aggregate: {
            args: Prisma.RecipeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecipe>
          }
          groupBy: {
            args: Prisma.RecipeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecipeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RecipeCountArgs<ExtArgs>
            result: $Utils.Optional<RecipeCountAggregateOutputType> | number
          }
        }
      }
      CraftInput: {
        payload: Prisma.$CraftInputPayload<ExtArgs>
        fields: Prisma.CraftInputFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CraftInputFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CraftInputFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>
          }
          findFirst: {
            args: Prisma.CraftInputFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CraftInputFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>
          }
          findMany: {
            args: Prisma.CraftInputFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>[]
          }
          create: {
            args: Prisma.CraftInputCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>
          }
          createMany: {
            args: Prisma.CraftInputCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CraftInputDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>
          }
          update: {
            args: Prisma.CraftInputUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>
          }
          deleteMany: {
            args: Prisma.CraftInputDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CraftInputUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CraftInputUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CraftInputPayload>
          }
          aggregate: {
            args: Prisma.CraftInputAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCraftInput>
          }
          groupBy: {
            args: Prisma.CraftInputGroupByArgs<ExtArgs>
            result: $Utils.Optional<CraftInputGroupByOutputType>[]
          }
          count: {
            args: Prisma.CraftInputCountArgs<ExtArgs>
            result: $Utils.Optional<CraftInputCountAggregateOutputType> | number
          }
        }
      }
      Pack: {
        payload: Prisma.$PackPayload<ExtArgs>
        fields: Prisma.PackFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>
          }
          findFirst: {
            args: Prisma.PackFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>
          }
          findMany: {
            args: Prisma.PackFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>[]
          }
          create: {
            args: Prisma.PackCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>
          }
          createMany: {
            args: Prisma.PackCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PackDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>
          }
          update: {
            args: Prisma.PackUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>
          }
          deleteMany: {
            args: Prisma.PackDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackPayload>
          }
          aggregate: {
            args: Prisma.PackAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePack>
          }
          groupBy: {
            args: Prisma.PackGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackCountArgs<ExtArgs>
            result: $Utils.Optional<PackCountAggregateOutputType> | number
          }
        }
      }
      PackItem: {
        payload: Prisma.$PackItemPayload<ExtArgs>
        fields: Prisma.PackItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PackItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PackItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>
          }
          findFirst: {
            args: Prisma.PackItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PackItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>
          }
          findMany: {
            args: Prisma.PackItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>[]
          }
          create: {
            args: Prisma.PackItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>
          }
          createMany: {
            args: Prisma.PackItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PackItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>
          }
          update: {
            args: Prisma.PackItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>
          }
          deleteMany: {
            args: Prisma.PackItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PackItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PackItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PackItemPayload>
          }
          aggregate: {
            args: Prisma.PackItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePackItem>
          }
          groupBy: {
            args: Prisma.PackItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PackItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PackItemCountArgs<ExtArgs>
            result: $Utils.Optional<PackItemCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    characters: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | AccountCountOutputTypeCountCharactersArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountCharactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
  }


  /**
   * Count Type CharacterCountOutputType
   */

  export type CharacterCountOutputType = {
    jobs: number
    packs: number
  }

  export type CharacterCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | CharacterCountOutputTypeCountJobsArgs
    packs?: boolean | CharacterCountOutputTypeCountPacksArgs
  }

  // Custom InputTypes
  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CharacterCountOutputType
     */
    select?: CharacterCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
  }

  /**
   * CharacterCountOutputType without action
   */
  export type CharacterCountOutputTypeCountPacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackWhereInput
  }


  /**
   * Count Type JobCountOutputType
   */

  export type JobCountOutputType = {
    activities: number
  }

  export type JobCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activities?: boolean | JobCountOutputTypeCountActivitiesArgs
  }

  // Custom InputTypes
  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCountOutputType
     */
    select?: JobCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCountOutputType without action
   */
  export type JobCountOutputTypeCountActivitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobActivityWhereInput
  }


  /**
   * Count Type ResourceCountOutputType
   */

  export type ResourceCountOutputType = {
    asInput: number
    asOutput: number
    packItems: number
  }

  export type ResourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asInput?: boolean | ResourceCountOutputTypeCountAsInputArgs
    asOutput?: boolean | ResourceCountOutputTypeCountAsOutputArgs
    packItems?: boolean | ResourceCountOutputTypeCountPackItemsArgs
  }

  // Custom InputTypes
  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ResourceCountOutputType
     */
    select?: ResourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountAsInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftInputWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountAsOutputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
  }

  /**
   * ResourceCountOutputType without action
   */
  export type ResourceCountOutputTypeCountPackItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackItemWhereInput
  }


  /**
   * Count Type RecipeCountOutputType
   */

  export type RecipeCountOutputType = {
    inputs: number
  }

  export type RecipeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inputs?: boolean | RecipeCountOutputTypeCountInputsArgs
  }

  // Custom InputTypes
  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecipeCountOutputType
     */
    select?: RecipeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecipeCountOutputType without action
   */
  export type RecipeCountOutputTypeCountInputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftInputWhereInput
  }


  /**
   * Count Type PackCountOutputType
   */

  export type PackCountOutputType = {
    items: number
  }

  export type PackCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PackCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PackCountOutputType without action
   */
  export type PackCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackCountOutputType
     */
    select?: PackCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PackCountOutputType without action
   */
  export type PackCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackItemWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    id: number | null
  }

  export type AccountSumAggregateOutputType = {
    id: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    isGoogle: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    isGoogle: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    isGoogle: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    id?: true
  }

  export type AccountSumAggregateInputType = {
    id?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    isGoogle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    isGoogle?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    isGoogle?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: number
    name: string
    email: string | null
    password: string | null
    isGoogle: boolean
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    isGoogle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    characters?: boolean | Account$charactersArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>


  export type AccountSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    isGoogle?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    characters?: boolean | Account$charactersArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      characters: Prisma.$CharacterPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string | null
      password: string | null
      isGoogle: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    characters<T extends Account$charactersArgs<ExtArgs> = {}>(args?: Subset<T, Account$charactersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'Int'>
    readonly name: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly isGoogle: FieldRef<"Account", 'Boolean'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.characters
   */
  export type Account$charactersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    cursor?: CharacterWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Character
   */

  export type AggregateCharacter = {
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  export type CharacterAvgAggregateOutputType = {
    id: number | null
    level: number | null
    accountId: number | null
  }

  export type CharacterSumAggregateOutputType = {
    id: number | null
    level: number | null
    accountId: number | null
  }

  export type CharacterMinAggregateOutputType = {
    id: number | null
    name: string | null
    class: string | null
    level: number | null
    server: string | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterMaxAggregateOutputType = {
    id: number | null
    name: string | null
    class: string | null
    level: number | null
    server: string | null
    accountId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CharacterCountAggregateOutputType = {
    id: number
    name: number
    class: number
    level: number
    server: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CharacterAvgAggregateInputType = {
    id?: true
    level?: true
    accountId?: true
  }

  export type CharacterSumAggregateInputType = {
    id?: true
    level?: true
    accountId?: true
  }

  export type CharacterMinAggregateInputType = {
    id?: true
    name?: true
    class?: true
    level?: true
    server?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterMaxAggregateInputType = {
    id?: true
    name?: true
    class?: true
    level?: true
    server?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CharacterCountAggregateInputType = {
    id?: true
    name?: true
    class?: true
    level?: true
    server?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CharacterAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Character to aggregate.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Characters
    **/
    _count?: true | CharacterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CharacterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CharacterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CharacterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CharacterMaxAggregateInputType
  }

  export type GetCharacterAggregateType<T extends CharacterAggregateArgs> = {
        [P in keyof T & keyof AggregateCharacter]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCharacter[P]>
      : GetScalarType<T[P], AggregateCharacter[P]>
  }




  export type CharacterGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CharacterWhereInput
    orderBy?: CharacterOrderByWithAggregationInput | CharacterOrderByWithAggregationInput[]
    by: CharacterScalarFieldEnum[] | CharacterScalarFieldEnum
    having?: CharacterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CharacterCountAggregateInputType | true
    _avg?: CharacterAvgAggregateInputType
    _sum?: CharacterSumAggregateInputType
    _min?: CharacterMinAggregateInputType
    _max?: CharacterMaxAggregateInputType
  }

  export type CharacterGroupByOutputType = {
    id: number
    name: string
    class: string
    level: number
    server: string
    accountId: number
    createdAt: Date
    updatedAt: Date
    _count: CharacterCountAggregateOutputType | null
    _avg: CharacterAvgAggregateOutputType | null
    _sum: CharacterSumAggregateOutputType | null
    _min: CharacterMinAggregateOutputType | null
    _max: CharacterMaxAggregateOutputType | null
  }

  type GetCharacterGroupByPayload<T extends CharacterGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CharacterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CharacterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CharacterGroupByOutputType[P]>
            : GetScalarType<T[P], CharacterGroupByOutputType[P]>
        }
      >
    >


  export type CharacterSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    class?: boolean
    level?: boolean
    server?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    jobs?: boolean | Character$jobsArgs<ExtArgs>
    packs?: boolean | Character$packsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["character"]>


  export type CharacterSelectScalar = {
    id?: boolean
    name?: boolean
    class?: boolean
    level?: boolean
    server?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CharacterInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    jobs?: boolean | Character$jobsArgs<ExtArgs>
    packs?: boolean | Character$packsArgs<ExtArgs>
    _count?: boolean | CharacterCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CharacterPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Character"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      jobs: Prisma.$JobPayload<ExtArgs>[]
      packs: Prisma.$PackPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      class: string
      level: number
      server: string
      accountId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["character"]>
    composites: {}
  }

  type CharacterGetPayload<S extends boolean | null | undefined | CharacterDefaultArgs> = $Result.GetResult<Prisma.$CharacterPayload, S>

  type CharacterCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CharacterFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CharacterCountAggregateInputType | true
    }

  export interface CharacterDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Character'], meta: { name: 'Character' } }
    /**
     * Find zero or one Character that matches the filter.
     * @param {CharacterFindUniqueArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CharacterFindUniqueArgs>(args: SelectSubset<T, CharacterFindUniqueArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Character that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CharacterFindUniqueOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CharacterFindUniqueOrThrowArgs>(args: SelectSubset<T, CharacterFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Character that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CharacterFindFirstArgs>(args?: SelectSubset<T, CharacterFindFirstArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Character that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindFirstOrThrowArgs} args - Arguments to find a Character
     * @example
     * // Get one Character
     * const character = await prisma.character.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CharacterFindFirstOrThrowArgs>(args?: SelectSubset<T, CharacterFindFirstOrThrowArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Characters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Characters
     * const characters = await prisma.character.findMany()
     * 
     * // Get first 10 Characters
     * const characters = await prisma.character.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const characterWithIdOnly = await prisma.character.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CharacterFindManyArgs>(args?: SelectSubset<T, CharacterFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Character.
     * @param {CharacterCreateArgs} args - Arguments to create a Character.
     * @example
     * // Create one Character
     * const Character = await prisma.character.create({
     *   data: {
     *     // ... data to create a Character
     *   }
     * })
     * 
     */
    create<T extends CharacterCreateArgs>(args: SelectSubset<T, CharacterCreateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Characters.
     * @param {CharacterCreateManyArgs} args - Arguments to create many Characters.
     * @example
     * // Create many Characters
     * const character = await prisma.character.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CharacterCreateManyArgs>(args?: SelectSubset<T, CharacterCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Character.
     * @param {CharacterDeleteArgs} args - Arguments to delete one Character.
     * @example
     * // Delete one Character
     * const Character = await prisma.character.delete({
     *   where: {
     *     // ... filter to delete one Character
     *   }
     * })
     * 
     */
    delete<T extends CharacterDeleteArgs>(args: SelectSubset<T, CharacterDeleteArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Character.
     * @param {CharacterUpdateArgs} args - Arguments to update one Character.
     * @example
     * // Update one Character
     * const character = await prisma.character.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CharacterUpdateArgs>(args: SelectSubset<T, CharacterUpdateArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Characters.
     * @param {CharacterDeleteManyArgs} args - Arguments to filter Characters to delete.
     * @example
     * // Delete a few Characters
     * const { count } = await prisma.character.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CharacterDeleteManyArgs>(args?: SelectSubset<T, CharacterDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Characters
     * const character = await prisma.character.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CharacterUpdateManyArgs>(args: SelectSubset<T, CharacterUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Character.
     * @param {CharacterUpsertArgs} args - Arguments to update or create a Character.
     * @example
     * // Update or create a Character
     * const character = await prisma.character.upsert({
     *   create: {
     *     // ... data to create a Character
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Character we want to update
     *   }
     * })
     */
    upsert<T extends CharacterUpsertArgs>(args: SelectSubset<T, CharacterUpsertArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Characters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterCountArgs} args - Arguments to filter Characters to count.
     * @example
     * // Count the number of Characters
     * const count = await prisma.character.count({
     *   where: {
     *     // ... the filter for the Characters we want to count
     *   }
     * })
    **/
    count<T extends CharacterCountArgs>(
      args?: Subset<T, CharacterCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CharacterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CharacterAggregateArgs>(args: Subset<T, CharacterAggregateArgs>): Prisma.PrismaPromise<GetCharacterAggregateType<T>>

    /**
     * Group by Character.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CharacterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CharacterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CharacterGroupByArgs['orderBy'] }
        : { orderBy?: CharacterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CharacterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCharacterGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Character model
   */
  readonly fields: CharacterFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Character.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CharacterClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jobs<T extends Character$jobsArgs<ExtArgs> = {}>(args?: Subset<T, Character$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany"> | Null>
    packs<T extends Character$packsArgs<ExtArgs> = {}>(args?: Subset<T, Character$packsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Character model
   */ 
  interface CharacterFieldRefs {
    readonly id: FieldRef<"Character", 'Int'>
    readonly name: FieldRef<"Character", 'String'>
    readonly class: FieldRef<"Character", 'String'>
    readonly level: FieldRef<"Character", 'Int'>
    readonly server: FieldRef<"Character", 'String'>
    readonly accountId: FieldRef<"Character", 'Int'>
    readonly createdAt: FieldRef<"Character", 'DateTime'>
    readonly updatedAt: FieldRef<"Character", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Character findUnique
   */
  export type CharacterFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findUniqueOrThrow
   */
  export type CharacterFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character findFirst
   */
  export type CharacterFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findFirstOrThrow
   */
  export type CharacterFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Character to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Characters.
     */
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character findMany
   */
  export type CharacterFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter, which Characters to fetch.
     */
    where?: CharacterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Characters to fetch.
     */
    orderBy?: CharacterOrderByWithRelationInput | CharacterOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Characters.
     */
    cursor?: CharacterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Characters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Characters.
     */
    skip?: number
    distinct?: CharacterScalarFieldEnum | CharacterScalarFieldEnum[]
  }

  /**
   * Character create
   */
  export type CharacterCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to create a Character.
     */
    data: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
  }

  /**
   * Character createMany
   */
  export type CharacterCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Characters.
     */
    data: CharacterCreateManyInput | CharacterCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Character update
   */
  export type CharacterUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The data needed to update a Character.
     */
    data: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
    /**
     * Choose, which Character to update.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character updateMany
   */
  export type CharacterUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Characters.
     */
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyInput>
    /**
     * Filter which Characters to update
     */
    where?: CharacterWhereInput
  }

  /**
   * Character upsert
   */
  export type CharacterUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * The filter to search for the Character to update in case it exists.
     */
    where: CharacterWhereUniqueInput
    /**
     * In case the Character found by the `where` argument doesn't exist, create a new Character with this data.
     */
    create: XOR<CharacterCreateInput, CharacterUncheckedCreateInput>
    /**
     * In case the Character was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CharacterUpdateInput, CharacterUncheckedUpdateInput>
  }

  /**
   * Character delete
   */
  export type CharacterDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    /**
     * Filter which Character to delete.
     */
    where: CharacterWhereUniqueInput
  }

  /**
   * Character deleteMany
   */
  export type CharacterDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Characters to delete
     */
    where?: CharacterWhereInput
  }

  /**
   * Character.jobs
   */
  export type Character$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    where?: JobWhereInput
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    cursor?: JobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Character.packs
   */
  export type Character$packsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    where?: PackWhereInput
    orderBy?: PackOrderByWithRelationInput | PackOrderByWithRelationInput[]
    cursor?: PackWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackScalarFieldEnum | PackScalarFieldEnum[]
  }

  /**
   * Character without action
   */
  export type CharacterDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
  }


  /**
   * Model Job
   */

  export type AggregateJob = {
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  export type JobAvgAggregateOutputType = {
    id: number | null
    level: number | null
    currentXP: number | null
    characterId: number | null
  }

  export type JobSumAggregateOutputType = {
    id: number | null
    level: number | null
    currentXP: number | null
    characterId: number | null
  }

  export type JobMinAggregateOutputType = {
    id: number | null
    name: string | null
    level: number | null
    currentXP: number | null
    icon: string | null
    characterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobMaxAggregateOutputType = {
    id: number | null
    name: string | null
    level: number | null
    currentXP: number | null
    icon: string | null
    characterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type JobCountAggregateOutputType = {
    id: number
    name: number
    level: number
    currentXP: number
    icon: number
    characterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type JobAvgAggregateInputType = {
    id?: true
    level?: true
    currentXP?: true
    characterId?: true
  }

  export type JobSumAggregateInputType = {
    id?: true
    level?: true
    currentXP?: true
    characterId?: true
  }

  export type JobMinAggregateInputType = {
    id?: true
    name?: true
    level?: true
    currentXP?: true
    icon?: true
    characterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobMaxAggregateInputType = {
    id?: true
    name?: true
    level?: true
    currentXP?: true
    icon?: true
    characterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type JobCountAggregateInputType = {
    id?: true
    name?: true
    level?: true
    currentXP?: true
    icon?: true
    characterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type JobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Job to aggregate.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Jobs
    **/
    _count?: true | JobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobMaxAggregateInputType
  }

  export type GetJobAggregateType<T extends JobAggregateArgs> = {
        [P in keyof T & keyof AggregateJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob[P]>
      : GetScalarType<T[P], AggregateJob[P]>
  }




  export type JobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobWhereInput
    orderBy?: JobOrderByWithAggregationInput | JobOrderByWithAggregationInput[]
    by: JobScalarFieldEnum[] | JobScalarFieldEnum
    having?: JobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCountAggregateInputType | true
    _avg?: JobAvgAggregateInputType
    _sum?: JobSumAggregateInputType
    _min?: JobMinAggregateInputType
    _max?: JobMaxAggregateInputType
  }

  export type JobGroupByOutputType = {
    id: number
    name: string
    level: number
    currentXP: number
    icon: string
    characterId: number
    createdAt: Date
    updatedAt: Date
    _count: JobCountAggregateOutputType | null
    _avg: JobAvgAggregateOutputType | null
    _sum: JobSumAggregateOutputType | null
    _min: JobMinAggregateOutputType | null
    _max: JobMaxAggregateOutputType | null
  }

  type GetJobGroupByPayload<T extends JobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobGroupByOutputType[P]>
            : GetScalarType<T[P], JobGroupByOutputType[P]>
        }
      >
    >


  export type JobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    level?: boolean
    currentXP?: boolean
    icon?: boolean
    characterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    activities?: boolean | Job$activitiesArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["job"]>


  export type JobSelectScalar = {
    id?: boolean
    name?: boolean
    level?: boolean
    currentXP?: boolean
    icon?: boolean
    characterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type JobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | CharacterDefaultArgs<ExtArgs>
    activities?: boolean | Job$activitiesArgs<ExtArgs>
    _count?: boolean | JobCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Job"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs>
      activities: Prisma.$JobActivityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      level: number
      currentXP: number
      icon: string
      characterId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["job"]>
    composites: {}
  }

  type JobGetPayload<S extends boolean | null | undefined | JobDefaultArgs> = $Result.GetResult<Prisma.$JobPayload, S>

  type JobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobCountAggregateInputType | true
    }

  export interface JobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Job'], meta: { name: 'Job' } }
    /**
     * Find zero or one Job that matches the filter.
     * @param {JobFindUniqueArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobFindUniqueArgs>(args: SelectSubset<T, JobFindUniqueArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Job that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobFindUniqueOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobFindUniqueOrThrowArgs>(args: SelectSubset<T, JobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Job that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobFindFirstArgs>(args?: SelectSubset<T, JobFindFirstArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Job that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindFirstOrThrowArgs} args - Arguments to find a Job
     * @example
     * // Get one Job
     * const job = await prisma.job.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobFindFirstOrThrowArgs>(args?: SelectSubset<T, JobFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.job.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.job.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobWithIdOnly = await prisma.job.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobFindManyArgs>(args?: SelectSubset<T, JobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Job.
     * @param {JobCreateArgs} args - Arguments to create a Job.
     * @example
     * // Create one Job
     * const Job = await prisma.job.create({
     *   data: {
     *     // ... data to create a Job
     *   }
     * })
     * 
     */
    create<T extends JobCreateArgs>(args: SelectSubset<T, JobCreateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Jobs.
     * @param {JobCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const job = await prisma.job.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobCreateManyArgs>(args?: SelectSubset<T, JobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Job.
     * @param {JobDeleteArgs} args - Arguments to delete one Job.
     * @example
     * // Delete one Job
     * const Job = await prisma.job.delete({
     *   where: {
     *     // ... filter to delete one Job
     *   }
     * })
     * 
     */
    delete<T extends JobDeleteArgs>(args: SelectSubset<T, JobDeleteArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Job.
     * @param {JobUpdateArgs} args - Arguments to update one Job.
     * @example
     * // Update one Job
     * const job = await prisma.job.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobUpdateArgs>(args: SelectSubset<T, JobUpdateArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Jobs.
     * @param {JobDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.job.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobDeleteManyArgs>(args?: SelectSubset<T, JobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const job = await prisma.job.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobUpdateManyArgs>(args: SelectSubset<T, JobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job.
     * @param {JobUpsertArgs} args - Arguments to update or create a Job.
     * @example
     * // Update or create a Job
     * const job = await prisma.job.upsert({
     *   create: {
     *     // ... data to create a Job
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job we want to update
     *   }
     * })
     */
    upsert<T extends JobUpsertArgs>(args: SelectSubset<T, JobUpsertArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.job.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends JobCountArgs>(
      args?: Subset<T, JobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobAggregateArgs>(args: Subset<T, JobAggregateArgs>): Prisma.PrismaPromise<GetJobAggregateType<T>>

    /**
     * Group by Job.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobGroupByArgs['orderBy'] }
        : { orderBy?: JobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Job model
   */
  readonly fields: JobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Job.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends CharacterDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CharacterDefaultArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    activities<T extends Job$activitiesArgs<ExtArgs> = {}>(args?: Subset<T, Job$activitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Job model
   */ 
  interface JobFieldRefs {
    readonly id: FieldRef<"Job", 'Int'>
    readonly name: FieldRef<"Job", 'String'>
    readonly level: FieldRef<"Job", 'Int'>
    readonly currentXP: FieldRef<"Job", 'Int'>
    readonly icon: FieldRef<"Job", 'String'>
    readonly characterId: FieldRef<"Job", 'Int'>
    readonly createdAt: FieldRef<"Job", 'DateTime'>
    readonly updatedAt: FieldRef<"Job", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Job findUnique
   */
  export type JobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findUniqueOrThrow
   */
  export type JobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job findFirst
   */
  export type JobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findFirstOrThrow
   */
  export type JobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Job to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Jobs.
     */
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job findMany
   */
  export type JobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter, which Jobs to fetch.
     */
    where?: JobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Jobs to fetch.
     */
    orderBy?: JobOrderByWithRelationInput | JobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Jobs.
     */
    cursor?: JobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Jobs.
     */
    skip?: number
    distinct?: JobScalarFieldEnum | JobScalarFieldEnum[]
  }

  /**
   * Job create
   */
  export type JobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to create a Job.
     */
    data: XOR<JobCreateInput, JobUncheckedCreateInput>
  }

  /**
   * Job createMany
   */
  export type JobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Jobs.
     */
    data: JobCreateManyInput | JobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Job update
   */
  export type JobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The data needed to update a Job.
     */
    data: XOR<JobUpdateInput, JobUncheckedUpdateInput>
    /**
     * Choose, which Job to update.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job updateMany
   */
  export type JobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Jobs.
     */
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyInput>
    /**
     * Filter which Jobs to update
     */
    where?: JobWhereInput
  }

  /**
   * Job upsert
   */
  export type JobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * The filter to search for the Job to update in case it exists.
     */
    where: JobWhereUniqueInput
    /**
     * In case the Job found by the `where` argument doesn't exist, create a new Job with this data.
     */
    create: XOR<JobCreateInput, JobUncheckedCreateInput>
    /**
     * In case the Job was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobUpdateInput, JobUncheckedUpdateInput>
  }

  /**
   * Job delete
   */
  export type JobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
    /**
     * Filter which Job to delete.
     */
    where: JobWhereUniqueInput
  }

  /**
   * Job deleteMany
   */
  export type JobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Jobs to delete
     */
    where?: JobWhereInput
  }

  /**
   * Job.activities
   */
  export type Job$activitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    where?: JobActivityWhereInput
    orderBy?: JobActivityOrderByWithRelationInput | JobActivityOrderByWithRelationInput[]
    cursor?: JobActivityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobActivityScalarFieldEnum | JobActivityScalarFieldEnum[]
  }

  /**
   * Job without action
   */
  export type JobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Job
     */
    select?: JobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobInclude<ExtArgs> | null
  }


  /**
   * Model JobActivity
   */

  export type AggregateJobActivity = {
    _count: JobActivityCountAggregateOutputType | null
    _avg: JobActivityAvgAggregateOutputType | null
    _sum: JobActivitySumAggregateOutputType | null
    _min: JobActivityMinAggregateOutputType | null
    _max: JobActivityMaxAggregateOutputType | null
  }

  export type JobActivityAvgAggregateOutputType = {
    id: number | null
    jobId: number | null
    itemId: number | null
    quantity: number | null
    xpGained: number | null
  }

  export type JobActivitySumAggregateOutputType = {
    id: number | null
    jobId: number | null
    itemId: number | null
    quantity: number | null
    xpGained: number | null
  }

  export type JobActivityMinAggregateOutputType = {
    id: number | null
    jobId: number | null
    type: string | null
    itemId: number | null
    quantity: number | null
    xpGained: number | null
    createdAt: Date | null
  }

  export type JobActivityMaxAggregateOutputType = {
    id: number | null
    jobId: number | null
    type: string | null
    itemId: number | null
    quantity: number | null
    xpGained: number | null
    createdAt: Date | null
  }

  export type JobActivityCountAggregateOutputType = {
    id: number
    jobId: number
    type: number
    itemId: number
    quantity: number
    xpGained: number
    createdAt: number
    _all: number
  }


  export type JobActivityAvgAggregateInputType = {
    id?: true
    jobId?: true
    itemId?: true
    quantity?: true
    xpGained?: true
  }

  export type JobActivitySumAggregateInputType = {
    id?: true
    jobId?: true
    itemId?: true
    quantity?: true
    xpGained?: true
  }

  export type JobActivityMinAggregateInputType = {
    id?: true
    jobId?: true
    type?: true
    itemId?: true
    quantity?: true
    xpGained?: true
    createdAt?: true
  }

  export type JobActivityMaxAggregateInputType = {
    id?: true
    jobId?: true
    type?: true
    itemId?: true
    quantity?: true
    xpGained?: true
    createdAt?: true
  }

  export type JobActivityCountAggregateInputType = {
    id?: true
    jobId?: true
    type?: true
    itemId?: true
    quantity?: true
    xpGained?: true
    createdAt?: true
    _all?: true
  }

  export type JobActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobActivity to aggregate.
     */
    where?: JobActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobActivities to fetch.
     */
    orderBy?: JobActivityOrderByWithRelationInput | JobActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JobActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JobActivities
    **/
    _count?: true | JobActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobActivityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobActivitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobActivityMaxAggregateInputType
  }

  export type GetJobActivityAggregateType<T extends JobActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateJobActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobActivity[P]>
      : GetScalarType<T[P], AggregateJobActivity[P]>
  }




  export type JobActivityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JobActivityWhereInput
    orderBy?: JobActivityOrderByWithAggregationInput | JobActivityOrderByWithAggregationInput[]
    by: JobActivityScalarFieldEnum[] | JobActivityScalarFieldEnum
    having?: JobActivityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobActivityCountAggregateInputType | true
    _avg?: JobActivityAvgAggregateInputType
    _sum?: JobActivitySumAggregateInputType
    _min?: JobActivityMinAggregateInputType
    _max?: JobActivityMaxAggregateInputType
  }

  export type JobActivityGroupByOutputType = {
    id: number
    jobId: number
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt: Date
    _count: JobActivityCountAggregateOutputType | null
    _avg: JobActivityAvgAggregateOutputType | null
    _sum: JobActivitySumAggregateOutputType | null
    _min: JobActivityMinAggregateOutputType | null
    _max: JobActivityMaxAggregateOutputType | null
  }

  type GetJobActivityGroupByPayload<T extends JobActivityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobActivityGroupByOutputType[P]>
            : GetScalarType<T[P], JobActivityGroupByOutputType[P]>
        }
      >
    >


  export type JobActivitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jobId?: boolean
    type?: boolean
    itemId?: boolean
    quantity?: boolean
    xpGained?: boolean
    createdAt?: boolean
    job?: boolean | JobDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobActivity"]>


  export type JobActivitySelectScalar = {
    id?: boolean
    jobId?: boolean
    type?: boolean
    itemId?: boolean
    quantity?: boolean
    xpGained?: boolean
    createdAt?: boolean
  }

  export type JobActivityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | JobDefaultArgs<ExtArgs>
  }

  export type $JobActivityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JobActivity"
    objects: {
      job: Prisma.$JobPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      jobId: number
      type: string
      itemId: number
      quantity: number
      xpGained: number
      createdAt: Date
    }, ExtArgs["result"]["jobActivity"]>
    composites: {}
  }

  type JobActivityGetPayload<S extends boolean | null | undefined | JobActivityDefaultArgs> = $Result.GetResult<Prisma.$JobActivityPayload, S>

  type JobActivityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JobActivityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JobActivityCountAggregateInputType | true
    }

  export interface JobActivityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JobActivity'], meta: { name: 'JobActivity' } }
    /**
     * Find zero or one JobActivity that matches the filter.
     * @param {JobActivityFindUniqueArgs} args - Arguments to find a JobActivity
     * @example
     * // Get one JobActivity
     * const jobActivity = await prisma.jobActivity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JobActivityFindUniqueArgs>(args: SelectSubset<T, JobActivityFindUniqueArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JobActivity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JobActivityFindUniqueOrThrowArgs} args - Arguments to find a JobActivity
     * @example
     * // Get one JobActivity
     * const jobActivity = await prisma.jobActivity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JobActivityFindUniqueOrThrowArgs>(args: SelectSubset<T, JobActivityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JobActivity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityFindFirstArgs} args - Arguments to find a JobActivity
     * @example
     * // Get one JobActivity
     * const jobActivity = await prisma.jobActivity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JobActivityFindFirstArgs>(args?: SelectSubset<T, JobActivityFindFirstArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JobActivity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityFindFirstOrThrowArgs} args - Arguments to find a JobActivity
     * @example
     * // Get one JobActivity
     * const jobActivity = await prisma.jobActivity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JobActivityFindFirstOrThrowArgs>(args?: SelectSubset<T, JobActivityFindFirstOrThrowArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JobActivities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobActivities
     * const jobActivities = await prisma.jobActivity.findMany()
     * 
     * // Get first 10 JobActivities
     * const jobActivities = await prisma.jobActivity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobActivityWithIdOnly = await prisma.jobActivity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JobActivityFindManyArgs>(args?: SelectSubset<T, JobActivityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JobActivity.
     * @param {JobActivityCreateArgs} args - Arguments to create a JobActivity.
     * @example
     * // Create one JobActivity
     * const JobActivity = await prisma.jobActivity.create({
     *   data: {
     *     // ... data to create a JobActivity
     *   }
     * })
     * 
     */
    create<T extends JobActivityCreateArgs>(args: SelectSubset<T, JobActivityCreateArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JobActivities.
     * @param {JobActivityCreateManyArgs} args - Arguments to create many JobActivities.
     * @example
     * // Create many JobActivities
     * const jobActivity = await prisma.jobActivity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JobActivityCreateManyArgs>(args?: SelectSubset<T, JobActivityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JobActivity.
     * @param {JobActivityDeleteArgs} args - Arguments to delete one JobActivity.
     * @example
     * // Delete one JobActivity
     * const JobActivity = await prisma.jobActivity.delete({
     *   where: {
     *     // ... filter to delete one JobActivity
     *   }
     * })
     * 
     */
    delete<T extends JobActivityDeleteArgs>(args: SelectSubset<T, JobActivityDeleteArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JobActivity.
     * @param {JobActivityUpdateArgs} args - Arguments to update one JobActivity.
     * @example
     * // Update one JobActivity
     * const jobActivity = await prisma.jobActivity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JobActivityUpdateArgs>(args: SelectSubset<T, JobActivityUpdateArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JobActivities.
     * @param {JobActivityDeleteManyArgs} args - Arguments to filter JobActivities to delete.
     * @example
     * // Delete a few JobActivities
     * const { count } = await prisma.jobActivity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JobActivityDeleteManyArgs>(args?: SelectSubset<T, JobActivityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobActivities
     * const jobActivity = await prisma.jobActivity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JobActivityUpdateManyArgs>(args: SelectSubset<T, JobActivityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JobActivity.
     * @param {JobActivityUpsertArgs} args - Arguments to update or create a JobActivity.
     * @example
     * // Update or create a JobActivity
     * const jobActivity = await prisma.jobActivity.upsert({
     *   create: {
     *     // ... data to create a JobActivity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobActivity we want to update
     *   }
     * })
     */
    upsert<T extends JobActivityUpsertArgs>(args: SelectSubset<T, JobActivityUpsertArgs<ExtArgs>>): Prisma__JobActivityClient<$Result.GetResult<Prisma.$JobActivityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JobActivities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityCountArgs} args - Arguments to filter JobActivities to count.
     * @example
     * // Count the number of JobActivities
     * const count = await prisma.jobActivity.count({
     *   where: {
     *     // ... the filter for the JobActivities we want to count
     *   }
     * })
    **/
    count<T extends JobActivityCountArgs>(
      args?: Subset<T, JobActivityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobActivityAggregateArgs>(args: Subset<T, JobActivityAggregateArgs>): Prisma.PrismaPromise<GetJobActivityAggregateType<T>>

    /**
     * Group by JobActivity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobActivityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JobActivityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JobActivityGroupByArgs['orderBy'] }
        : { orderBy?: JobActivityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JobActivityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JobActivity model
   */
  readonly fields: JobActivityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JobActivity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JobActivityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends JobDefaultArgs<ExtArgs> = {}>(args?: Subset<T, JobDefaultArgs<ExtArgs>>): Prisma__JobClient<$Result.GetResult<Prisma.$JobPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JobActivity model
   */ 
  interface JobActivityFieldRefs {
    readonly id: FieldRef<"JobActivity", 'Int'>
    readonly jobId: FieldRef<"JobActivity", 'Int'>
    readonly type: FieldRef<"JobActivity", 'String'>
    readonly itemId: FieldRef<"JobActivity", 'Int'>
    readonly quantity: FieldRef<"JobActivity", 'Int'>
    readonly xpGained: FieldRef<"JobActivity", 'Int'>
    readonly createdAt: FieldRef<"JobActivity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JobActivity findUnique
   */
  export type JobActivityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * Filter, which JobActivity to fetch.
     */
    where: JobActivityWhereUniqueInput
  }

  /**
   * JobActivity findUniqueOrThrow
   */
  export type JobActivityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * Filter, which JobActivity to fetch.
     */
    where: JobActivityWhereUniqueInput
  }

  /**
   * JobActivity findFirst
   */
  export type JobActivityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * Filter, which JobActivity to fetch.
     */
    where?: JobActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobActivities to fetch.
     */
    orderBy?: JobActivityOrderByWithRelationInput | JobActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobActivities.
     */
    cursor?: JobActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobActivities.
     */
    distinct?: JobActivityScalarFieldEnum | JobActivityScalarFieldEnum[]
  }

  /**
   * JobActivity findFirstOrThrow
   */
  export type JobActivityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * Filter, which JobActivity to fetch.
     */
    where?: JobActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobActivities to fetch.
     */
    orderBy?: JobActivityOrderByWithRelationInput | JobActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JobActivities.
     */
    cursor?: JobActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobActivities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JobActivities.
     */
    distinct?: JobActivityScalarFieldEnum | JobActivityScalarFieldEnum[]
  }

  /**
   * JobActivity findMany
   */
  export type JobActivityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * Filter, which JobActivities to fetch.
     */
    where?: JobActivityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JobActivities to fetch.
     */
    orderBy?: JobActivityOrderByWithRelationInput | JobActivityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JobActivities.
     */
    cursor?: JobActivityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JobActivities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JobActivities.
     */
    skip?: number
    distinct?: JobActivityScalarFieldEnum | JobActivityScalarFieldEnum[]
  }

  /**
   * JobActivity create
   */
  export type JobActivityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * The data needed to create a JobActivity.
     */
    data: XOR<JobActivityCreateInput, JobActivityUncheckedCreateInput>
  }

  /**
   * JobActivity createMany
   */
  export type JobActivityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JobActivities.
     */
    data: JobActivityCreateManyInput | JobActivityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JobActivity update
   */
  export type JobActivityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * The data needed to update a JobActivity.
     */
    data: XOR<JobActivityUpdateInput, JobActivityUncheckedUpdateInput>
    /**
     * Choose, which JobActivity to update.
     */
    where: JobActivityWhereUniqueInput
  }

  /**
   * JobActivity updateMany
   */
  export type JobActivityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JobActivities.
     */
    data: XOR<JobActivityUpdateManyMutationInput, JobActivityUncheckedUpdateManyInput>
    /**
     * Filter which JobActivities to update
     */
    where?: JobActivityWhereInput
  }

  /**
   * JobActivity upsert
   */
  export type JobActivityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * The filter to search for the JobActivity to update in case it exists.
     */
    where: JobActivityWhereUniqueInput
    /**
     * In case the JobActivity found by the `where` argument doesn't exist, create a new JobActivity with this data.
     */
    create: XOR<JobActivityCreateInput, JobActivityUncheckedCreateInput>
    /**
     * In case the JobActivity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JobActivityUpdateInput, JobActivityUncheckedUpdateInput>
  }

  /**
   * JobActivity delete
   */
  export type JobActivityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
    /**
     * Filter which JobActivity to delete.
     */
    where: JobActivityWhereUniqueInput
  }

  /**
   * JobActivity deleteMany
   */
  export type JobActivityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JobActivities to delete
     */
    where?: JobActivityWhereInput
  }

  /**
   * JobActivity without action
   */
  export type JobActivityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobActivity
     */
    select?: JobActivitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JobActivityInclude<ExtArgs> | null
  }


  /**
   * Model Resource
   */

  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
    level: number | null
    baseXP: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
    level: number | null
    baseXP: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    jobType: string | null
    level: number | null
    baseXP: number | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    jobType: string | null
    level: number | null
    baseXP: number | null
    icon: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    name: number
    type: number
    jobType: number
    level: number
    baseXP: number
    icon: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
    level?: true
    baseXP?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
    level?: true
    baseXP?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    jobType?: true
    level?: true
    baseXP?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    jobType?: true
    level?: true
    baseXP?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    jobType?: true
    level?: true
    baseXP?: true
    icon?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ResourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resource to aggregate.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResourceWhereInput
    orderBy?: ResourceOrderByWithAggregationInput | ResourceOrderByWithAggregationInput[]
    by: ResourceScalarFieldEnum[] | ResourceScalarFieldEnum
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }

  export type ResourceGroupByOutputType = {
    id: number
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    jobType?: boolean
    level?: boolean
    baseXP?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    asInput?: boolean | Resource$asInputArgs<ExtArgs>
    asOutput?: boolean | Resource$asOutputArgs<ExtArgs>
    packItems?: boolean | Resource$packItemsArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["resource"]>


  export type ResourceSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    jobType?: boolean
    level?: boolean
    baseXP?: boolean
    icon?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ResourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    asInput?: boolean | Resource$asInputArgs<ExtArgs>
    asOutput?: boolean | Resource$asOutputArgs<ExtArgs>
    packItems?: boolean | Resource$packItemsArgs<ExtArgs>
    _count?: boolean | ResourceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ResourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Resource"
    objects: {
      asInput: Prisma.$CraftInputPayload<ExtArgs>[]
      asOutput: Prisma.$RecipePayload<ExtArgs>[]
      packItems: Prisma.$PackItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      jobType: string
      level: number
      baseXP: number
      icon: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["resource"]>
    composites: {}
  }

  type ResourceGetPayload<S extends boolean | null | undefined | ResourceDefaultArgs> = $Result.GetResult<Prisma.$ResourcePayload, S>

  type ResourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResourceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ResourceCountAggregateInputType | true
    }

  export interface ResourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Resource'], meta: { name: 'Resource' } }
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ResourceFindUniqueArgs>(args: SelectSubset<T, ResourceFindUniqueArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Resource that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ResourceFindUniqueOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ResourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ResourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ResourceFindFirstArgs>(args?: SelectSubset<T, ResourceFindFirstArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Resource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstOrThrowArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ResourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ResourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ResourceFindManyArgs>(args?: SelectSubset<T, ResourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
     */
    create<T extends ResourceCreateArgs>(args: SelectSubset<T, ResourceCreateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Resources.
     * @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     * @example
     * // Create many Resources
     * const resource = await prisma.resource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ResourceCreateManyArgs>(args?: SelectSubset<T, ResourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
     */
    delete<T extends ResourceDeleteArgs>(args: SelectSubset<T, ResourceDeleteArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ResourceUpdateArgs>(args: SelectSubset<T, ResourceUpdateArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ResourceDeleteManyArgs>(args?: SelectSubset<T, ResourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ResourceUpdateManyArgs>(args: SelectSubset<T, ResourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
     */
    upsert<T extends ResourceUpsertArgs>(args: SelectSubset<T, ResourceUpsertArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): Prisma.PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Resource model
   */
  readonly fields: ResourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    asInput<T extends Resource$asInputArgs<ExtArgs> = {}>(args?: Subset<T, Resource$asInputArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findMany"> | Null>
    asOutput<T extends Resource$asOutputArgs<ExtArgs> = {}>(args?: Subset<T, Resource$asOutputArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany"> | Null>
    packItems<T extends Resource$packItemsArgs<ExtArgs> = {}>(args?: Subset<T, Resource$packItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Resource model
   */ 
  interface ResourceFieldRefs {
    readonly id: FieldRef<"Resource", 'Int'>
    readonly name: FieldRef<"Resource", 'String'>
    readonly type: FieldRef<"Resource", 'String'>
    readonly jobType: FieldRef<"Resource", 'String'>
    readonly level: FieldRef<"Resource", 'Int'>
    readonly baseXP: FieldRef<"Resource", 'Int'>
    readonly icon: FieldRef<"Resource", 'String'>
    readonly description: FieldRef<"Resource", 'String'>
    readonly createdAt: FieldRef<"Resource", 'DateTime'>
    readonly updatedAt: FieldRef<"Resource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findUniqueOrThrow
   */
  export type ResourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findFirstOrThrow
   */
  export type ResourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resource to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     */
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter, which Resources to fetch.
     */
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     */
    orderBy?: ResourceOrderByWithRelationInput | ResourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     */
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     */
    skip?: number
    distinct?: ResourceScalarFieldEnum | ResourceScalarFieldEnum[]
  }

  /**
   * Resource create
   */
  export type ResourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to create a Resource.
     */
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }

  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Resources.
     */
    data: ResourceCreateManyInput | ResourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Resource update
   */
  export type ResourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The data needed to update a Resource.
     */
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Resources.
     */
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * The filter to search for the Resource to update in case it exists.
     */
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     */
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }

  /**
   * Resource delete
   */
  export type ResourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
    /**
     * Filter which Resource to delete.
     */
    where: ResourceWhereUniqueInput
  }

  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Resources to delete
     */
    where?: ResourceWhereInput
  }

  /**
   * Resource.asInput
   */
  export type Resource$asInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    where?: CraftInputWhereInput
    orderBy?: CraftInputOrderByWithRelationInput | CraftInputOrderByWithRelationInput[]
    cursor?: CraftInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CraftInputScalarFieldEnum | CraftInputScalarFieldEnum[]
  }

  /**
   * Resource.asOutput
   */
  export type Resource$asOutputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    cursor?: RecipeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Resource.packItems
   */
  export type Resource$packItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    where?: PackItemWhereInput
    orderBy?: PackItemOrderByWithRelationInput | PackItemOrderByWithRelationInput[]
    cursor?: PackItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackItemScalarFieldEnum | PackItemScalarFieldEnum[]
  }

  /**
   * Resource without action
   */
  export type ResourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Resource
     */
    select?: ResourceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ResourceInclude<ExtArgs> | null
  }


  /**
   * Model Recipe
   */

  export type AggregateRecipe = {
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  export type RecipeAvgAggregateOutputType = {
    id: number | null
    level: number | null
    baseXP: number | null
    outputId: number | null
    outputQty: number | null
  }

  export type RecipeSumAggregateOutputType = {
    id: number | null
    level: number | null
    baseXP: number | null
    outputId: number | null
    outputQty: number | null
  }

  export type RecipeMinAggregateOutputType = {
    id: number | null
    name: string | null
    jobType: string | null
    level: number | null
    baseXP: number | null
    outputId: number | null
    outputQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeMaxAggregateOutputType = {
    id: number | null
    name: string | null
    jobType: string | null
    level: number | null
    baseXP: number | null
    outputId: number | null
    outputQty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RecipeCountAggregateOutputType = {
    id: number
    name: number
    jobType: number
    level: number
    baseXP: number
    outputId: number
    outputQty: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RecipeAvgAggregateInputType = {
    id?: true
    level?: true
    baseXP?: true
    outputId?: true
    outputQty?: true
  }

  export type RecipeSumAggregateInputType = {
    id?: true
    level?: true
    baseXP?: true
    outputId?: true
    outputQty?: true
  }

  export type RecipeMinAggregateInputType = {
    id?: true
    name?: true
    jobType?: true
    level?: true
    baseXP?: true
    outputId?: true
    outputQty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeMaxAggregateInputType = {
    id?: true
    name?: true
    jobType?: true
    level?: true
    baseXP?: true
    outputId?: true
    outputQty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RecipeCountAggregateInputType = {
    id?: true
    name?: true
    jobType?: true
    level?: true
    baseXP?: true
    outputId?: true
    outputQty?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RecipeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipe to aggregate.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Recipes
    **/
    _count?: true | RecipeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecipeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecipeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecipeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecipeMaxAggregateInputType
  }

  export type GetRecipeAggregateType<T extends RecipeAggregateArgs> = {
        [P in keyof T & keyof AggregateRecipe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecipe[P]>
      : GetScalarType<T[P], AggregateRecipe[P]>
  }




  export type RecipeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RecipeWhereInput
    orderBy?: RecipeOrderByWithAggregationInput | RecipeOrderByWithAggregationInput[]
    by: RecipeScalarFieldEnum[] | RecipeScalarFieldEnum
    having?: RecipeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecipeCountAggregateInputType | true
    _avg?: RecipeAvgAggregateInputType
    _sum?: RecipeSumAggregateInputType
    _min?: RecipeMinAggregateInputType
    _max?: RecipeMaxAggregateInputType
  }

  export type RecipeGroupByOutputType = {
    id: number
    name: string
    jobType: string
    level: number
    baseXP: number
    outputId: number
    outputQty: number
    createdAt: Date
    updatedAt: Date
    _count: RecipeCountAggregateOutputType | null
    _avg: RecipeAvgAggregateOutputType | null
    _sum: RecipeSumAggregateOutputType | null
    _min: RecipeMinAggregateOutputType | null
    _max: RecipeMaxAggregateOutputType | null
  }

  type GetRecipeGroupByPayload<T extends RecipeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecipeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecipeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecipeGroupByOutputType[P]>
            : GetScalarType<T[P], RecipeGroupByOutputType[P]>
        }
      >
    >


  export type RecipeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    jobType?: boolean
    level?: boolean
    baseXP?: boolean
    outputId?: boolean
    outputQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    output?: boolean | ResourceDefaultArgs<ExtArgs>
    inputs?: boolean | Recipe$inputsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["recipe"]>


  export type RecipeSelectScalar = {
    id?: boolean
    name?: boolean
    jobType?: boolean
    level?: boolean
    baseXP?: boolean
    outputId?: boolean
    outputQty?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RecipeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    output?: boolean | ResourceDefaultArgs<ExtArgs>
    inputs?: boolean | Recipe$inputsArgs<ExtArgs>
    _count?: boolean | RecipeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RecipePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Recipe"
    objects: {
      output: Prisma.$ResourcePayload<ExtArgs>
      inputs: Prisma.$CraftInputPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      jobType: string
      level: number
      baseXP: number
      outputId: number
      outputQty: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["recipe"]>
    composites: {}
  }

  type RecipeGetPayload<S extends boolean | null | undefined | RecipeDefaultArgs> = $Result.GetResult<Prisma.$RecipePayload, S>

  type RecipeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RecipeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RecipeCountAggregateInputType | true
    }

  export interface RecipeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Recipe'], meta: { name: 'Recipe' } }
    /**
     * Find zero or one Recipe that matches the filter.
     * @param {RecipeFindUniqueArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RecipeFindUniqueArgs>(args: SelectSubset<T, RecipeFindUniqueArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Recipe that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RecipeFindUniqueOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RecipeFindUniqueOrThrowArgs>(args: SelectSubset<T, RecipeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Recipe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RecipeFindFirstArgs>(args?: SelectSubset<T, RecipeFindFirstArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Recipe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindFirstOrThrowArgs} args - Arguments to find a Recipe
     * @example
     * // Get one Recipe
     * const recipe = await prisma.recipe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RecipeFindFirstOrThrowArgs>(args?: SelectSubset<T, RecipeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Recipes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recipes
     * const recipes = await prisma.recipe.findMany()
     * 
     * // Get first 10 Recipes
     * const recipes = await prisma.recipe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recipeWithIdOnly = await prisma.recipe.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RecipeFindManyArgs>(args?: SelectSubset<T, RecipeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Recipe.
     * @param {RecipeCreateArgs} args - Arguments to create a Recipe.
     * @example
     * // Create one Recipe
     * const Recipe = await prisma.recipe.create({
     *   data: {
     *     // ... data to create a Recipe
     *   }
     * })
     * 
     */
    create<T extends RecipeCreateArgs>(args: SelectSubset<T, RecipeCreateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Recipes.
     * @param {RecipeCreateManyArgs} args - Arguments to create many Recipes.
     * @example
     * // Create many Recipes
     * const recipe = await prisma.recipe.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RecipeCreateManyArgs>(args?: SelectSubset<T, RecipeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Recipe.
     * @param {RecipeDeleteArgs} args - Arguments to delete one Recipe.
     * @example
     * // Delete one Recipe
     * const Recipe = await prisma.recipe.delete({
     *   where: {
     *     // ... filter to delete one Recipe
     *   }
     * })
     * 
     */
    delete<T extends RecipeDeleteArgs>(args: SelectSubset<T, RecipeDeleteArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Recipe.
     * @param {RecipeUpdateArgs} args - Arguments to update one Recipe.
     * @example
     * // Update one Recipe
     * const recipe = await prisma.recipe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RecipeUpdateArgs>(args: SelectSubset<T, RecipeUpdateArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Recipes.
     * @param {RecipeDeleteManyArgs} args - Arguments to filter Recipes to delete.
     * @example
     * // Delete a few Recipes
     * const { count } = await prisma.recipe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RecipeDeleteManyArgs>(args?: SelectSubset<T, RecipeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recipes
     * const recipe = await prisma.recipe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RecipeUpdateManyArgs>(args: SelectSubset<T, RecipeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Recipe.
     * @param {RecipeUpsertArgs} args - Arguments to update or create a Recipe.
     * @example
     * // Update or create a Recipe
     * const recipe = await prisma.recipe.upsert({
     *   create: {
     *     // ... data to create a Recipe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recipe we want to update
     *   }
     * })
     */
    upsert<T extends RecipeUpsertArgs>(args: SelectSubset<T, RecipeUpsertArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Recipes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeCountArgs} args - Arguments to filter Recipes to count.
     * @example
     * // Count the number of Recipes
     * const count = await prisma.recipe.count({
     *   where: {
     *     // ... the filter for the Recipes we want to count
     *   }
     * })
    **/
    count<T extends RecipeCountArgs>(
      args?: Subset<T, RecipeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecipeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecipeAggregateArgs>(args: Subset<T, RecipeAggregateArgs>): Prisma.PrismaPromise<GetRecipeAggregateType<T>>

    /**
     * Group by Recipe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecipeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RecipeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RecipeGroupByArgs['orderBy'] }
        : { orderBy?: RecipeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RecipeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecipeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Recipe model
   */
  readonly fields: RecipeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Recipe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RecipeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    output<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inputs<T extends Recipe$inputsArgs<ExtArgs> = {}>(args?: Subset<T, Recipe$inputsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Recipe model
   */ 
  interface RecipeFieldRefs {
    readonly id: FieldRef<"Recipe", 'Int'>
    readonly name: FieldRef<"Recipe", 'String'>
    readonly jobType: FieldRef<"Recipe", 'String'>
    readonly level: FieldRef<"Recipe", 'Int'>
    readonly baseXP: FieldRef<"Recipe", 'Int'>
    readonly outputId: FieldRef<"Recipe", 'Int'>
    readonly outputQty: FieldRef<"Recipe", 'Int'>
    readonly createdAt: FieldRef<"Recipe", 'DateTime'>
    readonly updatedAt: FieldRef<"Recipe", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Recipe findUnique
   */
  export type RecipeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findUniqueOrThrow
   */
  export type RecipeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe findFirst
   */
  export type RecipeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findFirstOrThrow
   */
  export type RecipeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipe to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Recipes.
     */
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe findMany
   */
  export type RecipeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter, which Recipes to fetch.
     */
    where?: RecipeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Recipes to fetch.
     */
    orderBy?: RecipeOrderByWithRelationInput | RecipeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Recipes.
     */
    cursor?: RecipeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Recipes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Recipes.
     */
    skip?: number
    distinct?: RecipeScalarFieldEnum | RecipeScalarFieldEnum[]
  }

  /**
   * Recipe create
   */
  export type RecipeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to create a Recipe.
     */
    data: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
  }

  /**
   * Recipe createMany
   */
  export type RecipeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Recipes.
     */
    data: RecipeCreateManyInput | RecipeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Recipe update
   */
  export type RecipeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The data needed to update a Recipe.
     */
    data: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
    /**
     * Choose, which Recipe to update.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe updateMany
   */
  export type RecipeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Recipes.
     */
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyInput>
    /**
     * Filter which Recipes to update
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe upsert
   */
  export type RecipeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * The filter to search for the Recipe to update in case it exists.
     */
    where: RecipeWhereUniqueInput
    /**
     * In case the Recipe found by the `where` argument doesn't exist, create a new Recipe with this data.
     */
    create: XOR<RecipeCreateInput, RecipeUncheckedCreateInput>
    /**
     * In case the Recipe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RecipeUpdateInput, RecipeUncheckedUpdateInput>
  }

  /**
   * Recipe delete
   */
  export type RecipeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
    /**
     * Filter which Recipe to delete.
     */
    where: RecipeWhereUniqueInput
  }

  /**
   * Recipe deleteMany
   */
  export type RecipeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Recipes to delete
     */
    where?: RecipeWhereInput
  }

  /**
   * Recipe.inputs
   */
  export type Recipe$inputsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    where?: CraftInputWhereInput
    orderBy?: CraftInputOrderByWithRelationInput | CraftInputOrderByWithRelationInput[]
    cursor?: CraftInputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CraftInputScalarFieldEnum | CraftInputScalarFieldEnum[]
  }

  /**
   * Recipe without action
   */
  export type RecipeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Recipe
     */
    select?: RecipeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RecipeInclude<ExtArgs> | null
  }


  /**
   * Model CraftInput
   */

  export type AggregateCraftInput = {
    _count: CraftInputCountAggregateOutputType | null
    _avg: CraftInputAvgAggregateOutputType | null
    _sum: CraftInputSumAggregateOutputType | null
    _min: CraftInputMinAggregateOutputType | null
    _max: CraftInputMaxAggregateOutputType | null
  }

  export type CraftInputAvgAggregateOutputType = {
    id: number | null
    recipeId: number | null
    resourceId: number | null
    quantity: number | null
  }

  export type CraftInputSumAggregateOutputType = {
    id: number | null
    recipeId: number | null
    resourceId: number | null
    quantity: number | null
  }

  export type CraftInputMinAggregateOutputType = {
    id: number | null
    recipeId: number | null
    resourceId: number | null
    quantity: number | null
  }

  export type CraftInputMaxAggregateOutputType = {
    id: number | null
    recipeId: number | null
    resourceId: number | null
    quantity: number | null
  }

  export type CraftInputCountAggregateOutputType = {
    id: number
    recipeId: number
    resourceId: number
    quantity: number
    _all: number
  }


  export type CraftInputAvgAggregateInputType = {
    id?: true
    recipeId?: true
    resourceId?: true
    quantity?: true
  }

  export type CraftInputSumAggregateInputType = {
    id?: true
    recipeId?: true
    resourceId?: true
    quantity?: true
  }

  export type CraftInputMinAggregateInputType = {
    id?: true
    recipeId?: true
    resourceId?: true
    quantity?: true
  }

  export type CraftInputMaxAggregateInputType = {
    id?: true
    recipeId?: true
    resourceId?: true
    quantity?: true
  }

  export type CraftInputCountAggregateInputType = {
    id?: true
    recipeId?: true
    resourceId?: true
    quantity?: true
    _all?: true
  }

  export type CraftInputAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CraftInput to aggregate.
     */
    where?: CraftInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftInputs to fetch.
     */
    orderBy?: CraftInputOrderByWithRelationInput | CraftInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CraftInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CraftInputs
    **/
    _count?: true | CraftInputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CraftInputAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CraftInputSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CraftInputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CraftInputMaxAggregateInputType
  }

  export type GetCraftInputAggregateType<T extends CraftInputAggregateArgs> = {
        [P in keyof T & keyof AggregateCraftInput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCraftInput[P]>
      : GetScalarType<T[P], AggregateCraftInput[P]>
  }




  export type CraftInputGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CraftInputWhereInput
    orderBy?: CraftInputOrderByWithAggregationInput | CraftInputOrderByWithAggregationInput[]
    by: CraftInputScalarFieldEnum[] | CraftInputScalarFieldEnum
    having?: CraftInputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CraftInputCountAggregateInputType | true
    _avg?: CraftInputAvgAggregateInputType
    _sum?: CraftInputSumAggregateInputType
    _min?: CraftInputMinAggregateInputType
    _max?: CraftInputMaxAggregateInputType
  }

  export type CraftInputGroupByOutputType = {
    id: number
    recipeId: number
    resourceId: number
    quantity: number
    _count: CraftInputCountAggregateOutputType | null
    _avg: CraftInputAvgAggregateOutputType | null
    _sum: CraftInputSumAggregateOutputType | null
    _min: CraftInputMinAggregateOutputType | null
    _max: CraftInputMaxAggregateOutputType | null
  }

  type GetCraftInputGroupByPayload<T extends CraftInputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CraftInputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CraftInputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CraftInputGroupByOutputType[P]>
            : GetScalarType<T[P], CraftInputGroupByOutputType[P]>
        }
      >
    >


  export type CraftInputSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipeId?: boolean
    resourceId?: boolean
    quantity?: boolean
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["craftInput"]>


  export type CraftInputSelectScalar = {
    id?: boolean
    recipeId?: boolean
    resourceId?: boolean
    quantity?: boolean
  }

  export type CraftInputInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipe?: boolean | RecipeDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $CraftInputPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CraftInput"
    objects: {
      recipe: Prisma.$RecipePayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      recipeId: number
      resourceId: number
      quantity: number
    }, ExtArgs["result"]["craftInput"]>
    composites: {}
  }

  type CraftInputGetPayload<S extends boolean | null | undefined | CraftInputDefaultArgs> = $Result.GetResult<Prisma.$CraftInputPayload, S>

  type CraftInputCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CraftInputFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CraftInputCountAggregateInputType | true
    }

  export interface CraftInputDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CraftInput'], meta: { name: 'CraftInput' } }
    /**
     * Find zero or one CraftInput that matches the filter.
     * @param {CraftInputFindUniqueArgs} args - Arguments to find a CraftInput
     * @example
     * // Get one CraftInput
     * const craftInput = await prisma.craftInput.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CraftInputFindUniqueArgs>(args: SelectSubset<T, CraftInputFindUniqueArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CraftInput that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CraftInputFindUniqueOrThrowArgs} args - Arguments to find a CraftInput
     * @example
     * // Get one CraftInput
     * const craftInput = await prisma.craftInput.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CraftInputFindUniqueOrThrowArgs>(args: SelectSubset<T, CraftInputFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CraftInput that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputFindFirstArgs} args - Arguments to find a CraftInput
     * @example
     * // Get one CraftInput
     * const craftInput = await prisma.craftInput.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CraftInputFindFirstArgs>(args?: SelectSubset<T, CraftInputFindFirstArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CraftInput that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputFindFirstOrThrowArgs} args - Arguments to find a CraftInput
     * @example
     * // Get one CraftInput
     * const craftInput = await prisma.craftInput.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CraftInputFindFirstOrThrowArgs>(args?: SelectSubset<T, CraftInputFindFirstOrThrowArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CraftInputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CraftInputs
     * const craftInputs = await prisma.craftInput.findMany()
     * 
     * // Get first 10 CraftInputs
     * const craftInputs = await prisma.craftInput.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const craftInputWithIdOnly = await prisma.craftInput.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CraftInputFindManyArgs>(args?: SelectSubset<T, CraftInputFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CraftInput.
     * @param {CraftInputCreateArgs} args - Arguments to create a CraftInput.
     * @example
     * // Create one CraftInput
     * const CraftInput = await prisma.craftInput.create({
     *   data: {
     *     // ... data to create a CraftInput
     *   }
     * })
     * 
     */
    create<T extends CraftInputCreateArgs>(args: SelectSubset<T, CraftInputCreateArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CraftInputs.
     * @param {CraftInputCreateManyArgs} args - Arguments to create many CraftInputs.
     * @example
     * // Create many CraftInputs
     * const craftInput = await prisma.craftInput.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CraftInputCreateManyArgs>(args?: SelectSubset<T, CraftInputCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CraftInput.
     * @param {CraftInputDeleteArgs} args - Arguments to delete one CraftInput.
     * @example
     * // Delete one CraftInput
     * const CraftInput = await prisma.craftInput.delete({
     *   where: {
     *     // ... filter to delete one CraftInput
     *   }
     * })
     * 
     */
    delete<T extends CraftInputDeleteArgs>(args: SelectSubset<T, CraftInputDeleteArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CraftInput.
     * @param {CraftInputUpdateArgs} args - Arguments to update one CraftInput.
     * @example
     * // Update one CraftInput
     * const craftInput = await prisma.craftInput.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CraftInputUpdateArgs>(args: SelectSubset<T, CraftInputUpdateArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CraftInputs.
     * @param {CraftInputDeleteManyArgs} args - Arguments to filter CraftInputs to delete.
     * @example
     * // Delete a few CraftInputs
     * const { count } = await prisma.craftInput.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CraftInputDeleteManyArgs>(args?: SelectSubset<T, CraftInputDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CraftInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CraftInputs
     * const craftInput = await prisma.craftInput.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CraftInputUpdateManyArgs>(args: SelectSubset<T, CraftInputUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CraftInput.
     * @param {CraftInputUpsertArgs} args - Arguments to update or create a CraftInput.
     * @example
     * // Update or create a CraftInput
     * const craftInput = await prisma.craftInput.upsert({
     *   create: {
     *     // ... data to create a CraftInput
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CraftInput we want to update
     *   }
     * })
     */
    upsert<T extends CraftInputUpsertArgs>(args: SelectSubset<T, CraftInputUpsertArgs<ExtArgs>>): Prisma__CraftInputClient<$Result.GetResult<Prisma.$CraftInputPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CraftInputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputCountArgs} args - Arguments to filter CraftInputs to count.
     * @example
     * // Count the number of CraftInputs
     * const count = await prisma.craftInput.count({
     *   where: {
     *     // ... the filter for the CraftInputs we want to count
     *   }
     * })
    **/
    count<T extends CraftInputCountArgs>(
      args?: Subset<T, CraftInputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CraftInputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CraftInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CraftInputAggregateArgs>(args: Subset<T, CraftInputAggregateArgs>): Prisma.PrismaPromise<GetCraftInputAggregateType<T>>

    /**
     * Group by CraftInput.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CraftInputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CraftInputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CraftInputGroupByArgs['orderBy'] }
        : { orderBy?: CraftInputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CraftInputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCraftInputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CraftInput model
   */
  readonly fields: CraftInputFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CraftInput.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CraftInputClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipe<T extends RecipeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RecipeDefaultArgs<ExtArgs>>): Prisma__RecipeClient<$Result.GetResult<Prisma.$RecipePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CraftInput model
   */ 
  interface CraftInputFieldRefs {
    readonly id: FieldRef<"CraftInput", 'Int'>
    readonly recipeId: FieldRef<"CraftInput", 'Int'>
    readonly resourceId: FieldRef<"CraftInput", 'Int'>
    readonly quantity: FieldRef<"CraftInput", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CraftInput findUnique
   */
  export type CraftInputFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * Filter, which CraftInput to fetch.
     */
    where: CraftInputWhereUniqueInput
  }

  /**
   * CraftInput findUniqueOrThrow
   */
  export type CraftInputFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * Filter, which CraftInput to fetch.
     */
    where: CraftInputWhereUniqueInput
  }

  /**
   * CraftInput findFirst
   */
  export type CraftInputFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * Filter, which CraftInput to fetch.
     */
    where?: CraftInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftInputs to fetch.
     */
    orderBy?: CraftInputOrderByWithRelationInput | CraftInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CraftInputs.
     */
    cursor?: CraftInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CraftInputs.
     */
    distinct?: CraftInputScalarFieldEnum | CraftInputScalarFieldEnum[]
  }

  /**
   * CraftInput findFirstOrThrow
   */
  export type CraftInputFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * Filter, which CraftInput to fetch.
     */
    where?: CraftInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftInputs to fetch.
     */
    orderBy?: CraftInputOrderByWithRelationInput | CraftInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CraftInputs.
     */
    cursor?: CraftInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftInputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CraftInputs.
     */
    distinct?: CraftInputScalarFieldEnum | CraftInputScalarFieldEnum[]
  }

  /**
   * CraftInput findMany
   */
  export type CraftInputFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * Filter, which CraftInputs to fetch.
     */
    where?: CraftInputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CraftInputs to fetch.
     */
    orderBy?: CraftInputOrderByWithRelationInput | CraftInputOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CraftInputs.
     */
    cursor?: CraftInputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CraftInputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CraftInputs.
     */
    skip?: number
    distinct?: CraftInputScalarFieldEnum | CraftInputScalarFieldEnum[]
  }

  /**
   * CraftInput create
   */
  export type CraftInputCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * The data needed to create a CraftInput.
     */
    data: XOR<CraftInputCreateInput, CraftInputUncheckedCreateInput>
  }

  /**
   * CraftInput createMany
   */
  export type CraftInputCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CraftInputs.
     */
    data: CraftInputCreateManyInput | CraftInputCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CraftInput update
   */
  export type CraftInputUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * The data needed to update a CraftInput.
     */
    data: XOR<CraftInputUpdateInput, CraftInputUncheckedUpdateInput>
    /**
     * Choose, which CraftInput to update.
     */
    where: CraftInputWhereUniqueInput
  }

  /**
   * CraftInput updateMany
   */
  export type CraftInputUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CraftInputs.
     */
    data: XOR<CraftInputUpdateManyMutationInput, CraftInputUncheckedUpdateManyInput>
    /**
     * Filter which CraftInputs to update
     */
    where?: CraftInputWhereInput
  }

  /**
   * CraftInput upsert
   */
  export type CraftInputUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * The filter to search for the CraftInput to update in case it exists.
     */
    where: CraftInputWhereUniqueInput
    /**
     * In case the CraftInput found by the `where` argument doesn't exist, create a new CraftInput with this data.
     */
    create: XOR<CraftInputCreateInput, CraftInputUncheckedCreateInput>
    /**
     * In case the CraftInput was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CraftInputUpdateInput, CraftInputUncheckedUpdateInput>
  }

  /**
   * CraftInput delete
   */
  export type CraftInputDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
    /**
     * Filter which CraftInput to delete.
     */
    where: CraftInputWhereUniqueInput
  }

  /**
   * CraftInput deleteMany
   */
  export type CraftInputDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CraftInputs to delete
     */
    where?: CraftInputWhereInput
  }

  /**
   * CraftInput without action
   */
  export type CraftInputDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CraftInput
     */
    select?: CraftInputSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CraftInputInclude<ExtArgs> | null
  }


  /**
   * Model Pack
   */

  export type AggregatePack = {
    _count: PackCountAggregateOutputType | null
    _avg: PackAvgAggregateOutputType | null
    _sum: PackSumAggregateOutputType | null
    _min: PackMinAggregateOutputType | null
    _max: PackMaxAggregateOutputType | null
  }

  export type PackAvgAggregateOutputType = {
    id: number | null
    startLevel: number | null
    targetLevel: number | null
    characterId: number | null
  }

  export type PackSumAggregateOutputType = {
    id: number | null
    startLevel: number | null
    targetLevel: number | null
    characterId: number | null
  }

  export type PackMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    jobType: string | null
    startLevel: number | null
    targetLevel: number | null
    isTemplate: boolean | null
    characterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    jobType: string | null
    startLevel: number | null
    targetLevel: number | null
    isTemplate: boolean | null
    characterId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PackCountAggregateOutputType = {
    id: number
    name: number
    description: number
    jobType: number
    startLevel: number
    targetLevel: number
    isTemplate: number
    characterId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PackAvgAggregateInputType = {
    id?: true
    startLevel?: true
    targetLevel?: true
    characterId?: true
  }

  export type PackSumAggregateInputType = {
    id?: true
    startLevel?: true
    targetLevel?: true
    characterId?: true
  }

  export type PackMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    jobType?: true
    startLevel?: true
    targetLevel?: true
    isTemplate?: true
    characterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    jobType?: true
    startLevel?: true
    targetLevel?: true
    isTemplate?: true
    characterId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PackCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    jobType?: true
    startLevel?: true
    targetLevel?: true
    isTemplate?: true
    characterId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PackAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pack to aggregate.
     */
    where?: PackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packs to fetch.
     */
    orderBy?: PackOrderByWithRelationInput | PackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Packs
    **/
    _count?: true | PackCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackMaxAggregateInputType
  }

  export type GetPackAggregateType<T extends PackAggregateArgs> = {
        [P in keyof T & keyof AggregatePack]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePack[P]>
      : GetScalarType<T[P], AggregatePack[P]>
  }




  export type PackGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackWhereInput
    orderBy?: PackOrderByWithAggregationInput | PackOrderByWithAggregationInput[]
    by: PackScalarFieldEnum[] | PackScalarFieldEnum
    having?: PackScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackCountAggregateInputType | true
    _avg?: PackAvgAggregateInputType
    _sum?: PackSumAggregateInputType
    _min?: PackMinAggregateInputType
    _max?: PackMaxAggregateInputType
  }

  export type PackGroupByOutputType = {
    id: number
    name: string
    description: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate: boolean
    characterId: number | null
    createdAt: Date
    updatedAt: Date
    _count: PackCountAggregateOutputType | null
    _avg: PackAvgAggregateOutputType | null
    _sum: PackSumAggregateOutputType | null
    _min: PackMinAggregateOutputType | null
    _max: PackMaxAggregateOutputType | null
  }

  type GetPackGroupByPayload<T extends PackGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackGroupByOutputType[P]>
            : GetScalarType<T[P], PackGroupByOutputType[P]>
        }
      >
    >


  export type PackSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    jobType?: boolean
    startLevel?: boolean
    targetLevel?: boolean
    isTemplate?: boolean
    characterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    character?: boolean | Pack$characterArgs<ExtArgs>
    items?: boolean | Pack$itemsArgs<ExtArgs>
    _count?: boolean | PackCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pack"]>


  export type PackSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    jobType?: boolean
    startLevel?: boolean
    targetLevel?: boolean
    isTemplate?: boolean
    characterId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PackInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    character?: boolean | Pack$characterArgs<ExtArgs>
    items?: boolean | Pack$itemsArgs<ExtArgs>
    _count?: boolean | PackCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PackPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pack"
    objects: {
      character: Prisma.$CharacterPayload<ExtArgs> | null
      items: Prisma.$PackItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      jobType: string
      startLevel: number
      targetLevel: number
      isTemplate: boolean
      characterId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pack"]>
    composites: {}
  }

  type PackGetPayload<S extends boolean | null | undefined | PackDefaultArgs> = $Result.GetResult<Prisma.$PackPayload, S>

  type PackCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackCountAggregateInputType | true
    }

  export interface PackDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pack'], meta: { name: 'Pack' } }
    /**
     * Find zero or one Pack that matches the filter.
     * @param {PackFindUniqueArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackFindUniqueArgs>(args: SelectSubset<T, PackFindUniqueArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pack that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackFindUniqueOrThrowArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackFindUniqueOrThrowArgs>(args: SelectSubset<T, PackFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pack that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackFindFirstArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackFindFirstArgs>(args?: SelectSubset<T, PackFindFirstArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pack that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackFindFirstOrThrowArgs} args - Arguments to find a Pack
     * @example
     * // Get one Pack
     * const pack = await prisma.pack.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackFindFirstOrThrowArgs>(args?: SelectSubset<T, PackFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Packs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Packs
     * const packs = await prisma.pack.findMany()
     * 
     * // Get first 10 Packs
     * const packs = await prisma.pack.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packWithIdOnly = await prisma.pack.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackFindManyArgs>(args?: SelectSubset<T, PackFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pack.
     * @param {PackCreateArgs} args - Arguments to create a Pack.
     * @example
     * // Create one Pack
     * const Pack = await prisma.pack.create({
     *   data: {
     *     // ... data to create a Pack
     *   }
     * })
     * 
     */
    create<T extends PackCreateArgs>(args: SelectSubset<T, PackCreateArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Packs.
     * @param {PackCreateManyArgs} args - Arguments to create many Packs.
     * @example
     * // Create many Packs
     * const pack = await prisma.pack.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackCreateManyArgs>(args?: SelectSubset<T, PackCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pack.
     * @param {PackDeleteArgs} args - Arguments to delete one Pack.
     * @example
     * // Delete one Pack
     * const Pack = await prisma.pack.delete({
     *   where: {
     *     // ... filter to delete one Pack
     *   }
     * })
     * 
     */
    delete<T extends PackDeleteArgs>(args: SelectSubset<T, PackDeleteArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pack.
     * @param {PackUpdateArgs} args - Arguments to update one Pack.
     * @example
     * // Update one Pack
     * const pack = await prisma.pack.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackUpdateArgs>(args: SelectSubset<T, PackUpdateArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Packs.
     * @param {PackDeleteManyArgs} args - Arguments to filter Packs to delete.
     * @example
     * // Delete a few Packs
     * const { count } = await prisma.pack.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackDeleteManyArgs>(args?: SelectSubset<T, PackDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Packs
     * const pack = await prisma.pack.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackUpdateManyArgs>(args: SelectSubset<T, PackUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pack.
     * @param {PackUpsertArgs} args - Arguments to update or create a Pack.
     * @example
     * // Update or create a Pack
     * const pack = await prisma.pack.upsert({
     *   create: {
     *     // ... data to create a Pack
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pack we want to update
     *   }
     * })
     */
    upsert<T extends PackUpsertArgs>(args: SelectSubset<T, PackUpsertArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Packs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackCountArgs} args - Arguments to filter Packs to count.
     * @example
     * // Count the number of Packs
     * const count = await prisma.pack.count({
     *   where: {
     *     // ... the filter for the Packs we want to count
     *   }
     * })
    **/
    count<T extends PackCountArgs>(
      args?: Subset<T, PackCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackAggregateArgs>(args: Subset<T, PackAggregateArgs>): Prisma.PrismaPromise<GetPackAggregateType<T>>

    /**
     * Group by Pack.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackGroupByArgs['orderBy'] }
        : { orderBy?: PackGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pack model
   */
  readonly fields: PackFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pack.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    character<T extends Pack$characterArgs<ExtArgs> = {}>(args?: Subset<T, Pack$characterArgs<ExtArgs>>): Prisma__CharacterClient<$Result.GetResult<Prisma.$CharacterPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    items<T extends Pack$itemsArgs<ExtArgs> = {}>(args?: Subset<T, Pack$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pack model
   */ 
  interface PackFieldRefs {
    readonly id: FieldRef<"Pack", 'Int'>
    readonly name: FieldRef<"Pack", 'String'>
    readonly description: FieldRef<"Pack", 'String'>
    readonly jobType: FieldRef<"Pack", 'String'>
    readonly startLevel: FieldRef<"Pack", 'Int'>
    readonly targetLevel: FieldRef<"Pack", 'Int'>
    readonly isTemplate: FieldRef<"Pack", 'Boolean'>
    readonly characterId: FieldRef<"Pack", 'Int'>
    readonly createdAt: FieldRef<"Pack", 'DateTime'>
    readonly updatedAt: FieldRef<"Pack", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pack findUnique
   */
  export type PackFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * Filter, which Pack to fetch.
     */
    where: PackWhereUniqueInput
  }

  /**
   * Pack findUniqueOrThrow
   */
  export type PackFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * Filter, which Pack to fetch.
     */
    where: PackWhereUniqueInput
  }

  /**
   * Pack findFirst
   */
  export type PackFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * Filter, which Pack to fetch.
     */
    where?: PackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packs to fetch.
     */
    orderBy?: PackOrderByWithRelationInput | PackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packs.
     */
    cursor?: PackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packs.
     */
    distinct?: PackScalarFieldEnum | PackScalarFieldEnum[]
  }

  /**
   * Pack findFirstOrThrow
   */
  export type PackFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * Filter, which Pack to fetch.
     */
    where?: PackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packs to fetch.
     */
    orderBy?: PackOrderByWithRelationInput | PackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Packs.
     */
    cursor?: PackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Packs.
     */
    distinct?: PackScalarFieldEnum | PackScalarFieldEnum[]
  }

  /**
   * Pack findMany
   */
  export type PackFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * Filter, which Packs to fetch.
     */
    where?: PackWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Packs to fetch.
     */
    orderBy?: PackOrderByWithRelationInput | PackOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Packs.
     */
    cursor?: PackWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Packs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Packs.
     */
    skip?: number
    distinct?: PackScalarFieldEnum | PackScalarFieldEnum[]
  }

  /**
   * Pack create
   */
  export type PackCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * The data needed to create a Pack.
     */
    data: XOR<PackCreateInput, PackUncheckedCreateInput>
  }

  /**
   * Pack createMany
   */
  export type PackCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Packs.
     */
    data: PackCreateManyInput | PackCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pack update
   */
  export type PackUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * The data needed to update a Pack.
     */
    data: XOR<PackUpdateInput, PackUncheckedUpdateInput>
    /**
     * Choose, which Pack to update.
     */
    where: PackWhereUniqueInput
  }

  /**
   * Pack updateMany
   */
  export type PackUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Packs.
     */
    data: XOR<PackUpdateManyMutationInput, PackUncheckedUpdateManyInput>
    /**
     * Filter which Packs to update
     */
    where?: PackWhereInput
  }

  /**
   * Pack upsert
   */
  export type PackUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * The filter to search for the Pack to update in case it exists.
     */
    where: PackWhereUniqueInput
    /**
     * In case the Pack found by the `where` argument doesn't exist, create a new Pack with this data.
     */
    create: XOR<PackCreateInput, PackUncheckedCreateInput>
    /**
     * In case the Pack was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackUpdateInput, PackUncheckedUpdateInput>
  }

  /**
   * Pack delete
   */
  export type PackDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
    /**
     * Filter which Pack to delete.
     */
    where: PackWhereUniqueInput
  }

  /**
   * Pack deleteMany
   */
  export type PackDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Packs to delete
     */
    where?: PackWhereInput
  }

  /**
   * Pack.character
   */
  export type Pack$characterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Character
     */
    select?: CharacterSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CharacterInclude<ExtArgs> | null
    where?: CharacterWhereInput
  }

  /**
   * Pack.items
   */
  export type Pack$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    where?: PackItemWhereInput
    orderBy?: PackItemOrderByWithRelationInput | PackItemOrderByWithRelationInput[]
    cursor?: PackItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PackItemScalarFieldEnum | PackItemScalarFieldEnum[]
  }

  /**
   * Pack without action
   */
  export type PackDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pack
     */
    select?: PackSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackInclude<ExtArgs> | null
  }


  /**
   * Model PackItem
   */

  export type AggregatePackItem = {
    _count: PackItemCountAggregateOutputType | null
    _avg: PackItemAvgAggregateOutputType | null
    _sum: PackItemSumAggregateOutputType | null
    _min: PackItemMinAggregateOutputType | null
    _max: PackItemMaxAggregateOutputType | null
  }

  export type PackItemAvgAggregateOutputType = {
    id: number | null
    packId: number | null
    resourceId: number | null
    quantity: number | null
    obtained: number | null
  }

  export type PackItemSumAggregateOutputType = {
    id: number | null
    packId: number | null
    resourceId: number | null
    quantity: number | null
    obtained: number | null
  }

  export type PackItemMinAggregateOutputType = {
    id: number | null
    packId: number | null
    resourceId: number | null
    quantity: number | null
    obtained: number | null
  }

  export type PackItemMaxAggregateOutputType = {
    id: number | null
    packId: number | null
    resourceId: number | null
    quantity: number | null
    obtained: number | null
  }

  export type PackItemCountAggregateOutputType = {
    id: number
    packId: number
    resourceId: number
    quantity: number
    obtained: number
    _all: number
  }


  export type PackItemAvgAggregateInputType = {
    id?: true
    packId?: true
    resourceId?: true
    quantity?: true
    obtained?: true
  }

  export type PackItemSumAggregateInputType = {
    id?: true
    packId?: true
    resourceId?: true
    quantity?: true
    obtained?: true
  }

  export type PackItemMinAggregateInputType = {
    id?: true
    packId?: true
    resourceId?: true
    quantity?: true
    obtained?: true
  }

  export type PackItemMaxAggregateInputType = {
    id?: true
    packId?: true
    resourceId?: true
    quantity?: true
    obtained?: true
  }

  export type PackItemCountAggregateInputType = {
    id?: true
    packId?: true
    resourceId?: true
    quantity?: true
    obtained?: true
    _all?: true
  }

  export type PackItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackItem to aggregate.
     */
    where?: PackItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackItems to fetch.
     */
    orderBy?: PackItemOrderByWithRelationInput | PackItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PackItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PackItems
    **/
    _count?: true | PackItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PackItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PackItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PackItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PackItemMaxAggregateInputType
  }

  export type GetPackItemAggregateType<T extends PackItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePackItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePackItem[P]>
      : GetScalarType<T[P], AggregatePackItem[P]>
  }




  export type PackItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PackItemWhereInput
    orderBy?: PackItemOrderByWithAggregationInput | PackItemOrderByWithAggregationInput[]
    by: PackItemScalarFieldEnum[] | PackItemScalarFieldEnum
    having?: PackItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PackItemCountAggregateInputType | true
    _avg?: PackItemAvgAggregateInputType
    _sum?: PackItemSumAggregateInputType
    _min?: PackItemMinAggregateInputType
    _max?: PackItemMaxAggregateInputType
  }

  export type PackItemGroupByOutputType = {
    id: number
    packId: number
    resourceId: number
    quantity: number
    obtained: number
    _count: PackItemCountAggregateOutputType | null
    _avg: PackItemAvgAggregateOutputType | null
    _sum: PackItemSumAggregateOutputType | null
    _min: PackItemMinAggregateOutputType | null
    _max: PackItemMaxAggregateOutputType | null
  }

  type GetPackItemGroupByPayload<T extends PackItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PackItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PackItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PackItemGroupByOutputType[P]>
            : GetScalarType<T[P], PackItemGroupByOutputType[P]>
        }
      >
    >


  export type PackItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    packId?: boolean
    resourceId?: boolean
    quantity?: boolean
    obtained?: boolean
    pack?: boolean | PackDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["packItem"]>


  export type PackItemSelectScalar = {
    id?: boolean
    packId?: boolean
    resourceId?: boolean
    quantity?: boolean
    obtained?: boolean
  }

  export type PackItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pack?: boolean | PackDefaultArgs<ExtArgs>
    resource?: boolean | ResourceDefaultArgs<ExtArgs>
  }

  export type $PackItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PackItem"
    objects: {
      pack: Prisma.$PackPayload<ExtArgs>
      resource: Prisma.$ResourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      packId: number
      resourceId: number
      quantity: number
      obtained: number
    }, ExtArgs["result"]["packItem"]>
    composites: {}
  }

  type PackItemGetPayload<S extends boolean | null | undefined | PackItemDefaultArgs> = $Result.GetResult<Prisma.$PackItemPayload, S>

  type PackItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PackItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PackItemCountAggregateInputType | true
    }

  export interface PackItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PackItem'], meta: { name: 'PackItem' } }
    /**
     * Find zero or one PackItem that matches the filter.
     * @param {PackItemFindUniqueArgs} args - Arguments to find a PackItem
     * @example
     * // Get one PackItem
     * const packItem = await prisma.packItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PackItemFindUniqueArgs>(args: SelectSubset<T, PackItemFindUniqueArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PackItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PackItemFindUniqueOrThrowArgs} args - Arguments to find a PackItem
     * @example
     * // Get one PackItem
     * const packItem = await prisma.packItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PackItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PackItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PackItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemFindFirstArgs} args - Arguments to find a PackItem
     * @example
     * // Get one PackItem
     * const packItem = await prisma.packItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PackItemFindFirstArgs>(args?: SelectSubset<T, PackItemFindFirstArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PackItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemFindFirstOrThrowArgs} args - Arguments to find a PackItem
     * @example
     * // Get one PackItem
     * const packItem = await prisma.packItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PackItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PackItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PackItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PackItems
     * const packItems = await prisma.packItem.findMany()
     * 
     * // Get first 10 PackItems
     * const packItems = await prisma.packItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const packItemWithIdOnly = await prisma.packItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PackItemFindManyArgs>(args?: SelectSubset<T, PackItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PackItem.
     * @param {PackItemCreateArgs} args - Arguments to create a PackItem.
     * @example
     * // Create one PackItem
     * const PackItem = await prisma.packItem.create({
     *   data: {
     *     // ... data to create a PackItem
     *   }
     * })
     * 
     */
    create<T extends PackItemCreateArgs>(args: SelectSubset<T, PackItemCreateArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PackItems.
     * @param {PackItemCreateManyArgs} args - Arguments to create many PackItems.
     * @example
     * // Create many PackItems
     * const packItem = await prisma.packItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PackItemCreateManyArgs>(args?: SelectSubset<T, PackItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PackItem.
     * @param {PackItemDeleteArgs} args - Arguments to delete one PackItem.
     * @example
     * // Delete one PackItem
     * const PackItem = await prisma.packItem.delete({
     *   where: {
     *     // ... filter to delete one PackItem
     *   }
     * })
     * 
     */
    delete<T extends PackItemDeleteArgs>(args: SelectSubset<T, PackItemDeleteArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PackItem.
     * @param {PackItemUpdateArgs} args - Arguments to update one PackItem.
     * @example
     * // Update one PackItem
     * const packItem = await prisma.packItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PackItemUpdateArgs>(args: SelectSubset<T, PackItemUpdateArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PackItems.
     * @param {PackItemDeleteManyArgs} args - Arguments to filter PackItems to delete.
     * @example
     * // Delete a few PackItems
     * const { count } = await prisma.packItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PackItemDeleteManyArgs>(args?: SelectSubset<T, PackItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PackItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PackItems
     * const packItem = await prisma.packItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PackItemUpdateManyArgs>(args: SelectSubset<T, PackItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PackItem.
     * @param {PackItemUpsertArgs} args - Arguments to update or create a PackItem.
     * @example
     * // Update or create a PackItem
     * const packItem = await prisma.packItem.upsert({
     *   create: {
     *     // ... data to create a PackItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PackItem we want to update
     *   }
     * })
     */
    upsert<T extends PackItemUpsertArgs>(args: SelectSubset<T, PackItemUpsertArgs<ExtArgs>>): Prisma__PackItemClient<$Result.GetResult<Prisma.$PackItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PackItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemCountArgs} args - Arguments to filter PackItems to count.
     * @example
     * // Count the number of PackItems
     * const count = await prisma.packItem.count({
     *   where: {
     *     // ... the filter for the PackItems we want to count
     *   }
     * })
    **/
    count<T extends PackItemCountArgs>(
      args?: Subset<T, PackItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PackItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PackItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PackItemAggregateArgs>(args: Subset<T, PackItemAggregateArgs>): Prisma.PrismaPromise<GetPackItemAggregateType<T>>

    /**
     * Group by PackItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PackItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PackItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PackItemGroupByArgs['orderBy'] }
        : { orderBy?: PackItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PackItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPackItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PackItem model
   */
  readonly fields: PackItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PackItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PackItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pack<T extends PackDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PackDefaultArgs<ExtArgs>>): Prisma__PackClient<$Result.GetResult<Prisma.$PackPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resource<T extends ResourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ResourceDefaultArgs<ExtArgs>>): Prisma__ResourceClient<$Result.GetResult<Prisma.$ResourcePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PackItem model
   */ 
  interface PackItemFieldRefs {
    readonly id: FieldRef<"PackItem", 'Int'>
    readonly packId: FieldRef<"PackItem", 'Int'>
    readonly resourceId: FieldRef<"PackItem", 'Int'>
    readonly quantity: FieldRef<"PackItem", 'Int'>
    readonly obtained: FieldRef<"PackItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PackItem findUnique
   */
  export type PackItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * Filter, which PackItem to fetch.
     */
    where: PackItemWhereUniqueInput
  }

  /**
   * PackItem findUniqueOrThrow
   */
  export type PackItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * Filter, which PackItem to fetch.
     */
    where: PackItemWhereUniqueInput
  }

  /**
   * PackItem findFirst
   */
  export type PackItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * Filter, which PackItem to fetch.
     */
    where?: PackItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackItems to fetch.
     */
    orderBy?: PackItemOrderByWithRelationInput | PackItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackItems.
     */
    cursor?: PackItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackItems.
     */
    distinct?: PackItemScalarFieldEnum | PackItemScalarFieldEnum[]
  }

  /**
   * PackItem findFirstOrThrow
   */
  export type PackItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * Filter, which PackItem to fetch.
     */
    where?: PackItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackItems to fetch.
     */
    orderBy?: PackItemOrderByWithRelationInput | PackItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PackItems.
     */
    cursor?: PackItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PackItems.
     */
    distinct?: PackItemScalarFieldEnum | PackItemScalarFieldEnum[]
  }

  /**
   * PackItem findMany
   */
  export type PackItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * Filter, which PackItems to fetch.
     */
    where?: PackItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PackItems to fetch.
     */
    orderBy?: PackItemOrderByWithRelationInput | PackItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PackItems.
     */
    cursor?: PackItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PackItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PackItems.
     */
    skip?: number
    distinct?: PackItemScalarFieldEnum | PackItemScalarFieldEnum[]
  }

  /**
   * PackItem create
   */
  export type PackItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PackItem.
     */
    data: XOR<PackItemCreateInput, PackItemUncheckedCreateInput>
  }

  /**
   * PackItem createMany
   */
  export type PackItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PackItems.
     */
    data: PackItemCreateManyInput | PackItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PackItem update
   */
  export type PackItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PackItem.
     */
    data: XOR<PackItemUpdateInput, PackItemUncheckedUpdateInput>
    /**
     * Choose, which PackItem to update.
     */
    where: PackItemWhereUniqueInput
  }

  /**
   * PackItem updateMany
   */
  export type PackItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PackItems.
     */
    data: XOR<PackItemUpdateManyMutationInput, PackItemUncheckedUpdateManyInput>
    /**
     * Filter which PackItems to update
     */
    where?: PackItemWhereInput
  }

  /**
   * PackItem upsert
   */
  export type PackItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PackItem to update in case it exists.
     */
    where: PackItemWhereUniqueInput
    /**
     * In case the PackItem found by the `where` argument doesn't exist, create a new PackItem with this data.
     */
    create: XOR<PackItemCreateInput, PackItemUncheckedCreateInput>
    /**
     * In case the PackItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PackItemUpdateInput, PackItemUncheckedUpdateInput>
  }

  /**
   * PackItem delete
   */
  export type PackItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
    /**
     * Filter which PackItem to delete.
     */
    where: PackItemWhereUniqueInput
  }

  /**
   * PackItem deleteMany
   */
  export type PackItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PackItems to delete
     */
    where?: PackItemWhereInput
  }

  /**
   * PackItem without action
   */
  export type PackItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PackItem
     */
    select?: PackItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PackItemInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    isGoogle: 'isGoogle',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const CharacterScalarFieldEnum: {
    id: 'id',
    name: 'name',
    class: 'class',
    level: 'level',
    server: 'server',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CharacterScalarFieldEnum = (typeof CharacterScalarFieldEnum)[keyof typeof CharacterScalarFieldEnum]


  export const JobScalarFieldEnum: {
    id: 'id',
    name: 'name',
    level: 'level',
    currentXP: 'currentXP',
    icon: 'icon',
    characterId: 'characterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type JobScalarFieldEnum = (typeof JobScalarFieldEnum)[keyof typeof JobScalarFieldEnum]


  export const JobActivityScalarFieldEnum: {
    id: 'id',
    jobId: 'jobId',
    type: 'type',
    itemId: 'itemId',
    quantity: 'quantity',
    xpGained: 'xpGained',
    createdAt: 'createdAt'
  };

  export type JobActivityScalarFieldEnum = (typeof JobActivityScalarFieldEnum)[keyof typeof JobActivityScalarFieldEnum]


  export const ResourceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    jobType: 'jobType',
    level: 'level',
    baseXP: 'baseXP',
    icon: 'icon',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const RecipeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    jobType: 'jobType',
    level: 'level',
    baseXP: 'baseXP',
    outputId: 'outputId',
    outputQty: 'outputQty',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RecipeScalarFieldEnum = (typeof RecipeScalarFieldEnum)[keyof typeof RecipeScalarFieldEnum]


  export const CraftInputScalarFieldEnum: {
    id: 'id',
    recipeId: 'recipeId',
    resourceId: 'resourceId',
    quantity: 'quantity'
  };

  export type CraftInputScalarFieldEnum = (typeof CraftInputScalarFieldEnum)[keyof typeof CraftInputScalarFieldEnum]


  export const PackScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    jobType: 'jobType',
    startLevel: 'startLevel',
    targetLevel: 'targetLevel',
    isTemplate: 'isTemplate',
    characterId: 'characterId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PackScalarFieldEnum = (typeof PackScalarFieldEnum)[keyof typeof PackScalarFieldEnum]


  export const PackItemScalarFieldEnum: {
    id: 'id',
    packId: 'packId',
    resourceId: 'resourceId',
    quantity: 'quantity',
    obtained: 'obtained'
  };

  export type PackItemScalarFieldEnum = (typeof PackItemScalarFieldEnum)[keyof typeof PackItemScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: IntFilter<"Account"> | number
    name?: StringFilter<"Account"> | string
    email?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    isGoogle?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    characters?: CharacterListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    isGoogle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    characters?: CharacterOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    name?: StringFilter<"Account"> | string
    email?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    isGoogle?: BoolFilter<"Account"> | boolean
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    characters?: CharacterListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    isGoogle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Account"> | number
    name?: StringWithAggregatesFilter<"Account"> | string
    email?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    isGoogle?: BoolWithAggregatesFilter<"Account"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type CharacterWhereInput = {
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    id?: IntFilter<"Character"> | number
    name?: StringFilter<"Character"> | string
    class?: StringFilter<"Character"> | string
    level?: IntFilter<"Character"> | number
    server?: StringFilter<"Character"> | string
    accountId?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    jobs?: JobListRelationFilter
    packs?: PackListRelationFilter
  }

  export type CharacterOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    level?: SortOrder
    server?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    jobs?: JobOrderByRelationAggregateInput
    packs?: PackOrderByRelationAggregateInput
  }

  export type CharacterWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CharacterWhereInput | CharacterWhereInput[]
    OR?: CharacterWhereInput[]
    NOT?: CharacterWhereInput | CharacterWhereInput[]
    name?: StringFilter<"Character"> | string
    class?: StringFilter<"Character"> | string
    level?: IntFilter<"Character"> | number
    server?: StringFilter<"Character"> | string
    accountId?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    jobs?: JobListRelationFilter
    packs?: PackListRelationFilter
  }, "id">

  export type CharacterOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    level?: SortOrder
    server?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CharacterCountOrderByAggregateInput
    _avg?: CharacterAvgOrderByAggregateInput
    _max?: CharacterMaxOrderByAggregateInput
    _min?: CharacterMinOrderByAggregateInput
    _sum?: CharacterSumOrderByAggregateInput
  }

  export type CharacterScalarWhereWithAggregatesInput = {
    AND?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    OR?: CharacterScalarWhereWithAggregatesInput[]
    NOT?: CharacterScalarWhereWithAggregatesInput | CharacterScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Character"> | number
    name?: StringWithAggregatesFilter<"Character"> | string
    class?: StringWithAggregatesFilter<"Character"> | string
    level?: IntWithAggregatesFilter<"Character"> | number
    server?: StringWithAggregatesFilter<"Character"> | string
    accountId?: IntWithAggregatesFilter<"Character"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Character"> | Date | string
  }

  export type JobWhereInput = {
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    id?: IntFilter<"Job"> | number
    name?: StringFilter<"Job"> | string
    level?: IntFilter<"Job"> | number
    currentXP?: IntFilter<"Job"> | number
    icon?: StringFilter<"Job"> | string
    characterId?: IntFilter<"Job"> | number
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    activities?: JobActivityListRelationFilter
  }

  export type JobOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    icon?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
    activities?: JobActivityOrderByRelationAggregateInput
  }

  export type JobWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobWhereInput | JobWhereInput[]
    OR?: JobWhereInput[]
    NOT?: JobWhereInput | JobWhereInput[]
    name?: StringFilter<"Job"> | string
    level?: IntFilter<"Job"> | number
    currentXP?: IntFilter<"Job"> | number
    icon?: StringFilter<"Job"> | string
    characterId?: IntFilter<"Job"> | number
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
    character?: XOR<CharacterRelationFilter, CharacterWhereInput>
    activities?: JobActivityListRelationFilter
  }, "id">

  export type JobOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    icon?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: JobCountOrderByAggregateInput
    _avg?: JobAvgOrderByAggregateInput
    _max?: JobMaxOrderByAggregateInput
    _min?: JobMinOrderByAggregateInput
    _sum?: JobSumOrderByAggregateInput
  }

  export type JobScalarWhereWithAggregatesInput = {
    AND?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    OR?: JobScalarWhereWithAggregatesInput[]
    NOT?: JobScalarWhereWithAggregatesInput | JobScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Job"> | number
    name?: StringWithAggregatesFilter<"Job"> | string
    level?: IntWithAggregatesFilter<"Job"> | number
    currentXP?: IntWithAggregatesFilter<"Job"> | number
    icon?: StringWithAggregatesFilter<"Job"> | string
    characterId?: IntWithAggregatesFilter<"Job"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Job"> | Date | string
  }

  export type JobActivityWhereInput = {
    AND?: JobActivityWhereInput | JobActivityWhereInput[]
    OR?: JobActivityWhereInput[]
    NOT?: JobActivityWhereInput | JobActivityWhereInput[]
    id?: IntFilter<"JobActivity"> | number
    jobId?: IntFilter<"JobActivity"> | number
    type?: StringFilter<"JobActivity"> | string
    itemId?: IntFilter<"JobActivity"> | number
    quantity?: IntFilter<"JobActivity"> | number
    xpGained?: IntFilter<"JobActivity"> | number
    createdAt?: DateTimeFilter<"JobActivity"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }

  export type JobActivityOrderByWithRelationInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
    createdAt?: SortOrder
    job?: JobOrderByWithRelationInput
  }

  export type JobActivityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JobActivityWhereInput | JobActivityWhereInput[]
    OR?: JobActivityWhereInput[]
    NOT?: JobActivityWhereInput | JobActivityWhereInput[]
    jobId?: IntFilter<"JobActivity"> | number
    type?: StringFilter<"JobActivity"> | string
    itemId?: IntFilter<"JobActivity"> | number
    quantity?: IntFilter<"JobActivity"> | number
    xpGained?: IntFilter<"JobActivity"> | number
    createdAt?: DateTimeFilter<"JobActivity"> | Date | string
    job?: XOR<JobRelationFilter, JobWhereInput>
  }, "id">

  export type JobActivityOrderByWithAggregationInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
    createdAt?: SortOrder
    _count?: JobActivityCountOrderByAggregateInput
    _avg?: JobActivityAvgOrderByAggregateInput
    _max?: JobActivityMaxOrderByAggregateInput
    _min?: JobActivityMinOrderByAggregateInput
    _sum?: JobActivitySumOrderByAggregateInput
  }

  export type JobActivityScalarWhereWithAggregatesInput = {
    AND?: JobActivityScalarWhereWithAggregatesInput | JobActivityScalarWhereWithAggregatesInput[]
    OR?: JobActivityScalarWhereWithAggregatesInput[]
    NOT?: JobActivityScalarWhereWithAggregatesInput | JobActivityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JobActivity"> | number
    jobId?: IntWithAggregatesFilter<"JobActivity"> | number
    type?: StringWithAggregatesFilter<"JobActivity"> | string
    itemId?: IntWithAggregatesFilter<"JobActivity"> | number
    quantity?: IntWithAggregatesFilter<"JobActivity"> | number
    xpGained?: IntWithAggregatesFilter<"JobActivity"> | number
    createdAt?: DateTimeWithAggregatesFilter<"JobActivity"> | Date | string
  }

  export type ResourceWhereInput = {
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    id?: IntFilter<"Resource"> | number
    name?: StringFilter<"Resource"> | string
    type?: StringFilter<"Resource"> | string
    jobType?: StringFilter<"Resource"> | string
    level?: IntFilter<"Resource"> | number
    baseXP?: IntFilter<"Resource"> | number
    icon?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    asInput?: CraftInputListRelationFilter
    asOutput?: RecipeListRelationFilter
    packItems?: PackItemListRelationFilter
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    asInput?: CraftInputOrderByRelationAggregateInput
    asOutput?: RecipeOrderByRelationAggregateInput
    packItems?: PackItemOrderByRelationAggregateInput
  }

  export type ResourceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: ResourceWhereInput | ResourceWhereInput[]
    OR?: ResourceWhereInput[]
    NOT?: ResourceWhereInput | ResourceWhereInput[]
    type?: StringFilter<"Resource"> | string
    jobType?: StringFilter<"Resource"> | string
    level?: IntFilter<"Resource"> | number
    baseXP?: IntFilter<"Resource"> | number
    icon?: StringFilter<"Resource"> | string
    description?: StringNullableFilter<"Resource"> | string | null
    createdAt?: DateTimeFilter<"Resource"> | Date | string
    updatedAt?: DateTimeFilter<"Resource"> | Date | string
    asInput?: CraftInputListRelationFilter
    asOutput?: RecipeListRelationFilter
    packItems?: PackItemListRelationFilter
  }, "id" | "name">

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    icon?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    OR?: ResourceScalarWhereWithAggregatesInput[]
    NOT?: ResourceScalarWhereWithAggregatesInput | ResourceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Resource"> | number
    name?: StringWithAggregatesFilter<"Resource"> | string
    type?: StringWithAggregatesFilter<"Resource"> | string
    jobType?: StringWithAggregatesFilter<"Resource"> | string
    level?: IntWithAggregatesFilter<"Resource"> | number
    baseXP?: IntWithAggregatesFilter<"Resource"> | number
    icon?: StringWithAggregatesFilter<"Resource"> | string
    description?: StringNullableWithAggregatesFilter<"Resource"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Resource"> | Date | string
  }

  export type RecipeWhereInput = {
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    id?: IntFilter<"Recipe"> | number
    name?: StringFilter<"Recipe"> | string
    jobType?: StringFilter<"Recipe"> | string
    level?: IntFilter<"Recipe"> | number
    baseXP?: IntFilter<"Recipe"> | number
    outputId?: IntFilter<"Recipe"> | number
    outputQty?: IntFilter<"Recipe"> | number
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    output?: XOR<ResourceRelationFilter, ResourceWhereInput>
    inputs?: CraftInputListRelationFilter
  }

  export type RecipeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    output?: ResourceOrderByWithRelationInput
    inputs?: CraftInputOrderByRelationAggregateInput
  }

  export type RecipeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: RecipeWhereInput | RecipeWhereInput[]
    OR?: RecipeWhereInput[]
    NOT?: RecipeWhereInput | RecipeWhereInput[]
    jobType?: StringFilter<"Recipe"> | string
    level?: IntFilter<"Recipe"> | number
    baseXP?: IntFilter<"Recipe"> | number
    outputId?: IntFilter<"Recipe"> | number
    outputQty?: IntFilter<"Recipe"> | number
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
    output?: XOR<ResourceRelationFilter, ResourceWhereInput>
    inputs?: CraftInputListRelationFilter
  }, "id" | "name">

  export type RecipeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RecipeCountOrderByAggregateInput
    _avg?: RecipeAvgOrderByAggregateInput
    _max?: RecipeMaxOrderByAggregateInput
    _min?: RecipeMinOrderByAggregateInput
    _sum?: RecipeSumOrderByAggregateInput
  }

  export type RecipeScalarWhereWithAggregatesInput = {
    AND?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    OR?: RecipeScalarWhereWithAggregatesInput[]
    NOT?: RecipeScalarWhereWithAggregatesInput | RecipeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Recipe"> | number
    name?: StringWithAggregatesFilter<"Recipe"> | string
    jobType?: StringWithAggregatesFilter<"Recipe"> | string
    level?: IntWithAggregatesFilter<"Recipe"> | number
    baseXP?: IntWithAggregatesFilter<"Recipe"> | number
    outputId?: IntWithAggregatesFilter<"Recipe"> | number
    outputQty?: IntWithAggregatesFilter<"Recipe"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Recipe"> | Date | string
  }

  export type CraftInputWhereInput = {
    AND?: CraftInputWhereInput | CraftInputWhereInput[]
    OR?: CraftInputWhereInput[]
    NOT?: CraftInputWhereInput | CraftInputWhereInput[]
    id?: IntFilter<"CraftInput"> | number
    recipeId?: IntFilter<"CraftInput"> | number
    resourceId?: IntFilter<"CraftInput"> | number
    quantity?: IntFilter<"CraftInput"> | number
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }

  export type CraftInputOrderByWithRelationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    recipe?: RecipeOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type CraftInputWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CraftInputWhereInput | CraftInputWhereInput[]
    OR?: CraftInputWhereInput[]
    NOT?: CraftInputWhereInput | CraftInputWhereInput[]
    recipeId?: IntFilter<"CraftInput"> | number
    resourceId?: IntFilter<"CraftInput"> | number
    quantity?: IntFilter<"CraftInput"> | number
    recipe?: XOR<RecipeRelationFilter, RecipeWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }, "id">

  export type CraftInputOrderByWithAggregationInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    _count?: CraftInputCountOrderByAggregateInput
    _avg?: CraftInputAvgOrderByAggregateInput
    _max?: CraftInputMaxOrderByAggregateInput
    _min?: CraftInputMinOrderByAggregateInput
    _sum?: CraftInputSumOrderByAggregateInput
  }

  export type CraftInputScalarWhereWithAggregatesInput = {
    AND?: CraftInputScalarWhereWithAggregatesInput | CraftInputScalarWhereWithAggregatesInput[]
    OR?: CraftInputScalarWhereWithAggregatesInput[]
    NOT?: CraftInputScalarWhereWithAggregatesInput | CraftInputScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CraftInput"> | number
    recipeId?: IntWithAggregatesFilter<"CraftInput"> | number
    resourceId?: IntWithAggregatesFilter<"CraftInput"> | number
    quantity?: IntWithAggregatesFilter<"CraftInput"> | number
  }

  export type PackWhereInput = {
    AND?: PackWhereInput | PackWhereInput[]
    OR?: PackWhereInput[]
    NOT?: PackWhereInput | PackWhereInput[]
    id?: IntFilter<"Pack"> | number
    name?: StringFilter<"Pack"> | string
    description?: StringNullableFilter<"Pack"> | string | null
    jobType?: StringFilter<"Pack"> | string
    startLevel?: IntFilter<"Pack"> | number
    targetLevel?: IntFilter<"Pack"> | number
    isTemplate?: BoolFilter<"Pack"> | boolean
    characterId?: IntNullableFilter<"Pack"> | number | null
    createdAt?: DateTimeFilter<"Pack"> | Date | string
    updatedAt?: DateTimeFilter<"Pack"> | Date | string
    character?: XOR<CharacterNullableRelationFilter, CharacterWhereInput> | null
    items?: PackItemListRelationFilter
  }

  export type PackOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    jobType?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    isTemplate?: SortOrder
    characterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    character?: CharacterOrderByWithRelationInput
    items?: PackItemOrderByRelationAggregateInput
  }

  export type PackWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PackWhereInput | PackWhereInput[]
    OR?: PackWhereInput[]
    NOT?: PackWhereInput | PackWhereInput[]
    name?: StringFilter<"Pack"> | string
    description?: StringNullableFilter<"Pack"> | string | null
    jobType?: StringFilter<"Pack"> | string
    startLevel?: IntFilter<"Pack"> | number
    targetLevel?: IntFilter<"Pack"> | number
    isTemplate?: BoolFilter<"Pack"> | boolean
    characterId?: IntNullableFilter<"Pack"> | number | null
    createdAt?: DateTimeFilter<"Pack"> | Date | string
    updatedAt?: DateTimeFilter<"Pack"> | Date | string
    character?: XOR<CharacterNullableRelationFilter, CharacterWhereInput> | null
    items?: PackItemListRelationFilter
  }, "id">

  export type PackOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    jobType?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    isTemplate?: SortOrder
    characterId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PackCountOrderByAggregateInput
    _avg?: PackAvgOrderByAggregateInput
    _max?: PackMaxOrderByAggregateInput
    _min?: PackMinOrderByAggregateInput
    _sum?: PackSumOrderByAggregateInput
  }

  export type PackScalarWhereWithAggregatesInput = {
    AND?: PackScalarWhereWithAggregatesInput | PackScalarWhereWithAggregatesInput[]
    OR?: PackScalarWhereWithAggregatesInput[]
    NOT?: PackScalarWhereWithAggregatesInput | PackScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pack"> | number
    name?: StringWithAggregatesFilter<"Pack"> | string
    description?: StringNullableWithAggregatesFilter<"Pack"> | string | null
    jobType?: StringWithAggregatesFilter<"Pack"> | string
    startLevel?: IntWithAggregatesFilter<"Pack"> | number
    targetLevel?: IntWithAggregatesFilter<"Pack"> | number
    isTemplate?: BoolWithAggregatesFilter<"Pack"> | boolean
    characterId?: IntNullableWithAggregatesFilter<"Pack"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Pack"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pack"> | Date | string
  }

  export type PackItemWhereInput = {
    AND?: PackItemWhereInput | PackItemWhereInput[]
    OR?: PackItemWhereInput[]
    NOT?: PackItemWhereInput | PackItemWhereInput[]
    id?: IntFilter<"PackItem"> | number
    packId?: IntFilter<"PackItem"> | number
    resourceId?: IntFilter<"PackItem"> | number
    quantity?: IntFilter<"PackItem"> | number
    obtained?: IntFilter<"PackItem"> | number
    pack?: XOR<PackRelationFilter, PackWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }

  export type PackItemOrderByWithRelationInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
    pack?: PackOrderByWithRelationInput
    resource?: ResourceOrderByWithRelationInput
  }

  export type PackItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PackItemWhereInput | PackItemWhereInput[]
    OR?: PackItemWhereInput[]
    NOT?: PackItemWhereInput | PackItemWhereInput[]
    packId?: IntFilter<"PackItem"> | number
    resourceId?: IntFilter<"PackItem"> | number
    quantity?: IntFilter<"PackItem"> | number
    obtained?: IntFilter<"PackItem"> | number
    pack?: XOR<PackRelationFilter, PackWhereInput>
    resource?: XOR<ResourceRelationFilter, ResourceWhereInput>
  }, "id">

  export type PackItemOrderByWithAggregationInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
    _count?: PackItemCountOrderByAggregateInput
    _avg?: PackItemAvgOrderByAggregateInput
    _max?: PackItemMaxOrderByAggregateInput
    _min?: PackItemMinOrderByAggregateInput
    _sum?: PackItemSumOrderByAggregateInput
  }

  export type PackItemScalarWhereWithAggregatesInput = {
    AND?: PackItemScalarWhereWithAggregatesInput | PackItemScalarWhereWithAggregatesInput[]
    OR?: PackItemScalarWhereWithAggregatesInput[]
    NOT?: PackItemScalarWhereWithAggregatesInput | PackItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PackItem"> | number
    packId?: IntWithAggregatesFilter<"PackItem"> | number
    resourceId?: IntWithAggregatesFilter<"PackItem"> | number
    quantity?: IntWithAggregatesFilter<"PackItem"> | number
    obtained?: IntWithAggregatesFilter<"PackItem"> | number
  }

  export type AccountCreateInput = {
    name: string
    email?: string | null
    password?: string | null
    isGoogle?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: number
    name: string
    email?: string | null
    password?: string | null
    isGoogle?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    characters?: CharacterUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isGoogle?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isGoogle?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    characters?: CharacterUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: number
    name: string
    email?: string | null
    password?: string | null
    isGoogle?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isGoogle?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isGoogle?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterCreateInput = {
    name: string
    class: string
    level: number
    server: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCharactersInput
    jobs?: JobCreateNestedManyWithoutCharacterInput
    packs?: PackCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateInput = {
    id?: number
    name: string
    class: string
    level: number
    server: string
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutCharacterInput
    packs?: PackUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCharactersNestedInput
    jobs?: JobUpdateManyWithoutCharacterNestedInput
    packs?: PackUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutCharacterNestedInput
    packs?: PackUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterCreateManyInput = {
    id?: number
    name: string
    class: string
    level: number
    server: string
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CharacterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateInput = {
    name: string
    level?: number
    currentXP?: number
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutJobsInput
    activities?: JobActivityCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateInput = {
    id?: number
    name: string
    level?: number
    currentXP?: number
    icon: string
    characterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: JobActivityUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutJobsNestedInput
    activities?: JobActivityUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    characterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: JobActivityUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobCreateManyInput = {
    id?: number
    name: string
    level?: number
    currentXP?: number
    icon: string
    characterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    characterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobActivityCreateInput = {
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt?: Date | string
    job: JobCreateNestedOneWithoutActivitiesInput
  }

  export type JobActivityUncheckedCreateInput = {
    id?: number
    jobId: number
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt?: Date | string
  }

  export type JobActivityUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: JobUpdateOneRequiredWithoutActivitiesNestedInput
  }

  export type JobActivityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobActivityCreateManyInput = {
    id?: number
    jobId: number
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt?: Date | string
  }

  export type JobActivityUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobActivityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    jobId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceCreateInput = {
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asInput?: CraftInputCreateNestedManyWithoutResourceInput
    asOutput?: RecipeCreateNestedManyWithoutOutputInput
    packItems?: PackItemCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asInput?: CraftInputUncheckedCreateNestedManyWithoutResourceInput
    asOutput?: RecipeUncheckedCreateNestedManyWithoutOutputInput
    packItems?: PackItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asInput?: CraftInputUpdateManyWithoutResourceNestedInput
    asOutput?: RecipeUpdateManyWithoutOutputNestedInput
    packItems?: PackItemUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asInput?: CraftInputUncheckedUpdateManyWithoutResourceNestedInput
    asOutput?: RecipeUncheckedUpdateManyWithoutOutputNestedInput
    packItems?: PackItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type ResourceCreateManyInput = {
    id?: number
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ResourceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeCreateInput = {
    name: string
    jobType: string
    level: number
    baseXP: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    output: ResourceCreateNestedOneWithoutAsOutputInput
    inputs?: CraftInputCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateInput = {
    id?: number
    name: string
    jobType: string
    level: number
    baseXP: number
    outputId: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: CraftInputUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: ResourceUpdateOneRequiredWithoutAsOutputNestedInput
    inputs?: CraftInputUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputId?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: CraftInputUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeCreateManyInput = {
    id?: number
    name: string
    jobType: string
    level: number
    baseXP: number
    outputId: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RecipeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputId?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftInputCreateInput = {
    quantity: number
    recipe: RecipeCreateNestedOneWithoutInputsInput
    resource: ResourceCreateNestedOneWithoutAsInputInput
  }

  export type CraftInputUncheckedCreateInput = {
    id?: number
    recipeId: number
    resourceId: number
    quantity: number
  }

  export type CraftInputUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutInputsNestedInput
    resource?: ResourceUpdateOneRequiredWithoutAsInputNestedInput
  }

  export type CraftInputUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CraftInputCreateManyInput = {
    id?: number
    recipeId: number
    resourceId: number
    quantity: number
  }

  export type CraftInputUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CraftInputUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PackCreateInput = {
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    character?: CharacterCreateNestedOneWithoutPacksInput
    items?: PackItemCreateNestedManyWithoutPackInput
  }

  export type PackUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    characterId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PackItemUncheckedCreateNestedManyWithoutPackInput
  }

  export type PackUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutPacksNestedInput
    items?: PackItemUpdateManyWithoutPackNestedInput
  }

  export type PackUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PackItemUncheckedUpdateManyWithoutPackNestedInput
  }

  export type PackCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    characterId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackItemCreateInput = {
    quantity: number
    obtained?: number
    pack: PackCreateNestedOneWithoutItemsInput
    resource: ResourceCreateNestedOneWithoutPackItemsInput
  }

  export type PackItemUncheckedCreateInput = {
    id?: number
    packId: number
    resourceId: number
    quantity: number
    obtained?: number
  }

  export type PackItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
    pack?: PackUpdateOneRequiredWithoutItemsNestedInput
    resource?: ResourceUpdateOneRequiredWithoutPackItemsNestedInput
  }

  export type PackItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    packId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }

  export type PackItemCreateManyInput = {
    id?: number
    packId: number
    resourceId: number
    quantity: number
    obtained?: number
  }

  export type PackItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }

  export type PackItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    packId?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CharacterListRelationFilter = {
    every?: CharacterWhereInput
    some?: CharacterWhereInput
    none?: CharacterWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CharacterOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isGoogle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isGoogle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    isGoogle?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type JobListRelationFilter = {
    every?: JobWhereInput
    some?: JobWhereInput
    none?: JobWhereInput
  }

  export type PackListRelationFilter = {
    every?: PackWhereInput
    some?: PackWhereInput
    none?: PackWhereInput
  }

  export type JobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CharacterCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    level?: SortOrder
    server?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    accountId?: SortOrder
  }

  export type CharacterMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    level?: SortOrder
    server?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    class?: SortOrder
    level?: SortOrder
    server?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CharacterSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    accountId?: SortOrder
  }

  export type CharacterRelationFilter = {
    is?: CharacterWhereInput
    isNot?: CharacterWhereInput
  }

  export type JobActivityListRelationFilter = {
    every?: JobActivityWhereInput
    some?: JobActivityWhereInput
    none?: JobActivityWhereInput
  }

  export type JobActivityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JobCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    icon?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    characterId?: SortOrder
  }

  export type JobMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    icon?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    icon?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type JobSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    currentXP?: SortOrder
    characterId?: SortOrder
  }

  export type JobRelationFilter = {
    is?: JobWhereInput
    isNot?: JobWhereInput
  }

  export type JobActivityCountOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
    createdAt?: SortOrder
  }

  export type JobActivityAvgOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
  }

  export type JobActivityMaxOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
    createdAt?: SortOrder
  }

  export type JobActivityMinOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    type?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
    createdAt?: SortOrder
  }

  export type JobActivitySumOrderByAggregateInput = {
    id?: SortOrder
    jobId?: SortOrder
    itemId?: SortOrder
    quantity?: SortOrder
    xpGained?: SortOrder
  }

  export type CraftInputListRelationFilter = {
    every?: CraftInputWhereInput
    some?: CraftInputWhereInput
    none?: CraftInputWhereInput
  }

  export type RecipeListRelationFilter = {
    every?: RecipeWhereInput
    some?: RecipeWhereInput
    none?: RecipeWhereInput
  }

  export type PackItemListRelationFilter = {
    every?: PackItemWhereInput
    some?: PackItemWhereInput
    none?: PackItemWhereInput
  }

  export type CraftInputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RecipeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PackItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    icon?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
  }

  export type ResourceRelationFilter = {
    is?: ResourceWhereInput
    isNot?: ResourceWhereInput
  }

  export type RecipeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeAvgOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
  }

  export type RecipeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    jobType?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RecipeSumOrderByAggregateInput = {
    id?: SortOrder
    level?: SortOrder
    baseXP?: SortOrder
    outputId?: SortOrder
    outputQty?: SortOrder
  }

  export type RecipeRelationFilter = {
    is?: RecipeWhereInput
    isNot?: RecipeWhereInput
  }

  export type CraftInputCountOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
  }

  export type CraftInputAvgOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
  }

  export type CraftInputMaxOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
  }

  export type CraftInputMinOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
  }

  export type CraftInputSumOrderByAggregateInput = {
    id?: SortOrder
    recipeId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CharacterNullableRelationFilter = {
    is?: CharacterWhereInput | null
    isNot?: CharacterWhereInput | null
  }

  export type PackCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    jobType?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    isTemplate?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackAvgOrderByAggregateInput = {
    id?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    characterId?: SortOrder
  }

  export type PackMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    jobType?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    isTemplate?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    jobType?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    isTemplate?: SortOrder
    characterId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PackSumOrderByAggregateInput = {
    id?: SortOrder
    startLevel?: SortOrder
    targetLevel?: SortOrder
    characterId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PackRelationFilter = {
    is?: PackWhereInput
    isNot?: PackWhereInput
  }

  export type PackItemCountOrderByAggregateInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
  }

  export type PackItemAvgOrderByAggregateInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
  }

  export type PackItemMaxOrderByAggregateInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
  }

  export type PackItemMinOrderByAggregateInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
  }

  export type PackItemSumOrderByAggregateInput = {
    id?: SortOrder
    packId?: SortOrder
    resourceId?: SortOrder
    quantity?: SortOrder
    obtained?: SortOrder
  }

  export type CharacterCreateNestedManyWithoutAccountInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type CharacterUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CharacterUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAccountInput | CharacterUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAccountInput | CharacterUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAccountInput | CharacterUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CharacterUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput> | CharacterCreateWithoutAccountInput[] | CharacterUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: CharacterCreateOrConnectWithoutAccountInput | CharacterCreateOrConnectWithoutAccountInput[]
    upsert?: CharacterUpsertWithWhereUniqueWithoutAccountInput | CharacterUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: CharacterCreateManyAccountInputEnvelope
    set?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    disconnect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    delete?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    connect?: CharacterWhereUniqueInput | CharacterWhereUniqueInput[]
    update?: CharacterUpdateWithWhereUniqueWithoutAccountInput | CharacterUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: CharacterUpdateManyWithWhereWithoutAccountInput | CharacterUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutCharactersInput = {
    create?: XOR<AccountCreateWithoutCharactersInput, AccountUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCharactersInput
    connect?: AccountWhereUniqueInput
  }

  export type JobCreateNestedManyWithoutCharacterInput = {
    create?: XOR<JobCreateWithoutCharacterInput, JobUncheckedCreateWithoutCharacterInput> | JobCreateWithoutCharacterInput[] | JobUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCharacterInput | JobCreateOrConnectWithoutCharacterInput[]
    createMany?: JobCreateManyCharacterInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PackCreateNestedManyWithoutCharacterInput = {
    create?: XOR<PackCreateWithoutCharacterInput, PackUncheckedCreateWithoutCharacterInput> | PackCreateWithoutCharacterInput[] | PackUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: PackCreateOrConnectWithoutCharacterInput | PackCreateOrConnectWithoutCharacterInput[]
    createMany?: PackCreateManyCharacterInputEnvelope
    connect?: PackWhereUniqueInput | PackWhereUniqueInput[]
  }

  export type JobUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<JobCreateWithoutCharacterInput, JobUncheckedCreateWithoutCharacterInput> | JobCreateWithoutCharacterInput[] | JobUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCharacterInput | JobCreateOrConnectWithoutCharacterInput[]
    createMany?: JobCreateManyCharacterInputEnvelope
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
  }

  export type PackUncheckedCreateNestedManyWithoutCharacterInput = {
    create?: XOR<PackCreateWithoutCharacterInput, PackUncheckedCreateWithoutCharacterInput> | PackCreateWithoutCharacterInput[] | PackUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: PackCreateOrConnectWithoutCharacterInput | PackCreateOrConnectWithoutCharacterInput[]
    createMany?: PackCreateManyCharacterInputEnvelope
    connect?: PackWhereUniqueInput | PackWhereUniqueInput[]
  }

  export type AccountUpdateOneRequiredWithoutCharactersNestedInput = {
    create?: XOR<AccountCreateWithoutCharactersInput, AccountUncheckedCreateWithoutCharactersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutCharactersInput
    upsert?: AccountUpsertWithoutCharactersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutCharactersInput, AccountUpdateWithoutCharactersInput>, AccountUncheckedUpdateWithoutCharactersInput>
  }

  export type JobUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<JobCreateWithoutCharacterInput, JobUncheckedCreateWithoutCharacterInput> | JobCreateWithoutCharacterInput[] | JobUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCharacterInput | JobCreateOrConnectWithoutCharacterInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCharacterInput | JobUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: JobCreateManyCharacterInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCharacterInput | JobUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCharacterInput | JobUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PackUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<PackCreateWithoutCharacterInput, PackUncheckedCreateWithoutCharacterInput> | PackCreateWithoutCharacterInput[] | PackUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: PackCreateOrConnectWithoutCharacterInput | PackCreateOrConnectWithoutCharacterInput[]
    upsert?: PackUpsertWithWhereUniqueWithoutCharacterInput | PackUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: PackCreateManyCharacterInputEnvelope
    set?: PackWhereUniqueInput | PackWhereUniqueInput[]
    disconnect?: PackWhereUniqueInput | PackWhereUniqueInput[]
    delete?: PackWhereUniqueInput | PackWhereUniqueInput[]
    connect?: PackWhereUniqueInput | PackWhereUniqueInput[]
    update?: PackUpdateWithWhereUniqueWithoutCharacterInput | PackUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: PackUpdateManyWithWhereWithoutCharacterInput | PackUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: PackScalarWhereInput | PackScalarWhereInput[]
  }

  export type JobUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<JobCreateWithoutCharacterInput, JobUncheckedCreateWithoutCharacterInput> | JobCreateWithoutCharacterInput[] | JobUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: JobCreateOrConnectWithoutCharacterInput | JobCreateOrConnectWithoutCharacterInput[]
    upsert?: JobUpsertWithWhereUniqueWithoutCharacterInput | JobUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: JobCreateManyCharacterInputEnvelope
    set?: JobWhereUniqueInput | JobWhereUniqueInput[]
    disconnect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    delete?: JobWhereUniqueInput | JobWhereUniqueInput[]
    connect?: JobWhereUniqueInput | JobWhereUniqueInput[]
    update?: JobUpdateWithWhereUniqueWithoutCharacterInput | JobUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: JobUpdateManyWithWhereWithoutCharacterInput | JobUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: JobScalarWhereInput | JobScalarWhereInput[]
  }

  export type PackUncheckedUpdateManyWithoutCharacterNestedInput = {
    create?: XOR<PackCreateWithoutCharacterInput, PackUncheckedCreateWithoutCharacterInput> | PackCreateWithoutCharacterInput[] | PackUncheckedCreateWithoutCharacterInput[]
    connectOrCreate?: PackCreateOrConnectWithoutCharacterInput | PackCreateOrConnectWithoutCharacterInput[]
    upsert?: PackUpsertWithWhereUniqueWithoutCharacterInput | PackUpsertWithWhereUniqueWithoutCharacterInput[]
    createMany?: PackCreateManyCharacterInputEnvelope
    set?: PackWhereUniqueInput | PackWhereUniqueInput[]
    disconnect?: PackWhereUniqueInput | PackWhereUniqueInput[]
    delete?: PackWhereUniqueInput | PackWhereUniqueInput[]
    connect?: PackWhereUniqueInput | PackWhereUniqueInput[]
    update?: PackUpdateWithWhereUniqueWithoutCharacterInput | PackUpdateWithWhereUniqueWithoutCharacterInput[]
    updateMany?: PackUpdateManyWithWhereWithoutCharacterInput | PackUpdateManyWithWhereWithoutCharacterInput[]
    deleteMany?: PackScalarWhereInput | PackScalarWhereInput[]
  }

  export type CharacterCreateNestedOneWithoutJobsInput = {
    create?: XOR<CharacterCreateWithoutJobsInput, CharacterUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutJobsInput
    connect?: CharacterWhereUniqueInput
  }

  export type JobActivityCreateNestedManyWithoutJobInput = {
    create?: XOR<JobActivityCreateWithoutJobInput, JobActivityUncheckedCreateWithoutJobInput> | JobActivityCreateWithoutJobInput[] | JobActivityUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobActivityCreateOrConnectWithoutJobInput | JobActivityCreateOrConnectWithoutJobInput[]
    createMany?: JobActivityCreateManyJobInputEnvelope
    connect?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
  }

  export type JobActivityUncheckedCreateNestedManyWithoutJobInput = {
    create?: XOR<JobActivityCreateWithoutJobInput, JobActivityUncheckedCreateWithoutJobInput> | JobActivityCreateWithoutJobInput[] | JobActivityUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobActivityCreateOrConnectWithoutJobInput | JobActivityCreateOrConnectWithoutJobInput[]
    createMany?: JobActivityCreateManyJobInputEnvelope
    connect?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
  }

  export type CharacterUpdateOneRequiredWithoutJobsNestedInput = {
    create?: XOR<CharacterCreateWithoutJobsInput, CharacterUncheckedCreateWithoutJobsInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutJobsInput
    upsert?: CharacterUpsertWithoutJobsInput
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutJobsInput, CharacterUpdateWithoutJobsInput>, CharacterUncheckedUpdateWithoutJobsInput>
  }

  export type JobActivityUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobActivityCreateWithoutJobInput, JobActivityUncheckedCreateWithoutJobInput> | JobActivityCreateWithoutJobInput[] | JobActivityUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobActivityCreateOrConnectWithoutJobInput | JobActivityCreateOrConnectWithoutJobInput[]
    upsert?: JobActivityUpsertWithWhereUniqueWithoutJobInput | JobActivityUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobActivityCreateManyJobInputEnvelope
    set?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    disconnect?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    delete?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    connect?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    update?: JobActivityUpdateWithWhereUniqueWithoutJobInput | JobActivityUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobActivityUpdateManyWithWhereWithoutJobInput | JobActivityUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobActivityScalarWhereInput | JobActivityScalarWhereInput[]
  }

  export type JobActivityUncheckedUpdateManyWithoutJobNestedInput = {
    create?: XOR<JobActivityCreateWithoutJobInput, JobActivityUncheckedCreateWithoutJobInput> | JobActivityCreateWithoutJobInput[] | JobActivityUncheckedCreateWithoutJobInput[]
    connectOrCreate?: JobActivityCreateOrConnectWithoutJobInput | JobActivityCreateOrConnectWithoutJobInput[]
    upsert?: JobActivityUpsertWithWhereUniqueWithoutJobInput | JobActivityUpsertWithWhereUniqueWithoutJobInput[]
    createMany?: JobActivityCreateManyJobInputEnvelope
    set?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    disconnect?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    delete?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    connect?: JobActivityWhereUniqueInput | JobActivityWhereUniqueInput[]
    update?: JobActivityUpdateWithWhereUniqueWithoutJobInput | JobActivityUpdateWithWhereUniqueWithoutJobInput[]
    updateMany?: JobActivityUpdateManyWithWhereWithoutJobInput | JobActivityUpdateManyWithWhereWithoutJobInput[]
    deleteMany?: JobActivityScalarWhereInput | JobActivityScalarWhereInput[]
  }

  export type JobCreateNestedOneWithoutActivitiesInput = {
    create?: XOR<JobCreateWithoutActivitiesInput, JobUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: JobCreateOrConnectWithoutActivitiesInput
    connect?: JobWhereUniqueInput
  }

  export type JobUpdateOneRequiredWithoutActivitiesNestedInput = {
    create?: XOR<JobCreateWithoutActivitiesInput, JobUncheckedCreateWithoutActivitiesInput>
    connectOrCreate?: JobCreateOrConnectWithoutActivitiesInput
    upsert?: JobUpsertWithoutActivitiesInput
    connect?: JobWhereUniqueInput
    update?: XOR<XOR<JobUpdateToOneWithWhereWithoutActivitiesInput, JobUpdateWithoutActivitiesInput>, JobUncheckedUpdateWithoutActivitiesInput>
  }

  export type CraftInputCreateNestedManyWithoutResourceInput = {
    create?: XOR<CraftInputCreateWithoutResourceInput, CraftInputUncheckedCreateWithoutResourceInput> | CraftInputCreateWithoutResourceInput[] | CraftInputUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutResourceInput | CraftInputCreateOrConnectWithoutResourceInput[]
    createMany?: CraftInputCreateManyResourceInputEnvelope
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
  }

  export type RecipeCreateNestedManyWithoutOutputInput = {
    create?: XOR<RecipeCreateWithoutOutputInput, RecipeUncheckedCreateWithoutOutputInput> | RecipeCreateWithoutOutputInput[] | RecipeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutOutputInput | RecipeCreateOrConnectWithoutOutputInput[]
    createMany?: RecipeCreateManyOutputInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type PackItemCreateNestedManyWithoutResourceInput = {
    create?: XOR<PackItemCreateWithoutResourceInput, PackItemUncheckedCreateWithoutResourceInput> | PackItemCreateWithoutResourceInput[] | PackItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutResourceInput | PackItemCreateOrConnectWithoutResourceInput[]
    createMany?: PackItemCreateManyResourceInputEnvelope
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
  }

  export type CraftInputUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<CraftInputCreateWithoutResourceInput, CraftInputUncheckedCreateWithoutResourceInput> | CraftInputCreateWithoutResourceInput[] | CraftInputUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutResourceInput | CraftInputCreateOrConnectWithoutResourceInput[]
    createMany?: CraftInputCreateManyResourceInputEnvelope
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
  }

  export type RecipeUncheckedCreateNestedManyWithoutOutputInput = {
    create?: XOR<RecipeCreateWithoutOutputInput, RecipeUncheckedCreateWithoutOutputInput> | RecipeCreateWithoutOutputInput[] | RecipeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutOutputInput | RecipeCreateOrConnectWithoutOutputInput[]
    createMany?: RecipeCreateManyOutputInputEnvelope
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
  }

  export type PackItemUncheckedCreateNestedManyWithoutResourceInput = {
    create?: XOR<PackItemCreateWithoutResourceInput, PackItemUncheckedCreateWithoutResourceInput> | PackItemCreateWithoutResourceInput[] | PackItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutResourceInput | PackItemCreateOrConnectWithoutResourceInput[]
    createMany?: PackItemCreateManyResourceInputEnvelope
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
  }

  export type CraftInputUpdateManyWithoutResourceNestedInput = {
    create?: XOR<CraftInputCreateWithoutResourceInput, CraftInputUncheckedCreateWithoutResourceInput> | CraftInputCreateWithoutResourceInput[] | CraftInputUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutResourceInput | CraftInputCreateOrConnectWithoutResourceInput[]
    upsert?: CraftInputUpsertWithWhereUniqueWithoutResourceInput | CraftInputUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: CraftInputCreateManyResourceInputEnvelope
    set?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    disconnect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    delete?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    update?: CraftInputUpdateWithWhereUniqueWithoutResourceInput | CraftInputUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: CraftInputUpdateManyWithWhereWithoutResourceInput | CraftInputUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: CraftInputScalarWhereInput | CraftInputScalarWhereInput[]
  }

  export type RecipeUpdateManyWithoutOutputNestedInput = {
    create?: XOR<RecipeCreateWithoutOutputInput, RecipeUncheckedCreateWithoutOutputInput> | RecipeCreateWithoutOutputInput[] | RecipeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutOutputInput | RecipeCreateOrConnectWithoutOutputInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutOutputInput | RecipeUpsertWithWhereUniqueWithoutOutputInput[]
    createMany?: RecipeCreateManyOutputInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutOutputInput | RecipeUpdateWithWhereUniqueWithoutOutputInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutOutputInput | RecipeUpdateManyWithWhereWithoutOutputInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type PackItemUpdateManyWithoutResourceNestedInput = {
    create?: XOR<PackItemCreateWithoutResourceInput, PackItemUncheckedCreateWithoutResourceInput> | PackItemCreateWithoutResourceInput[] | PackItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutResourceInput | PackItemCreateOrConnectWithoutResourceInput[]
    upsert?: PackItemUpsertWithWhereUniqueWithoutResourceInput | PackItemUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: PackItemCreateManyResourceInputEnvelope
    set?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    disconnect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    delete?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    update?: PackItemUpdateWithWhereUniqueWithoutResourceInput | PackItemUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: PackItemUpdateManyWithWhereWithoutResourceInput | PackItemUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: PackItemScalarWhereInput | PackItemScalarWhereInput[]
  }

  export type CraftInputUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<CraftInputCreateWithoutResourceInput, CraftInputUncheckedCreateWithoutResourceInput> | CraftInputCreateWithoutResourceInput[] | CraftInputUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutResourceInput | CraftInputCreateOrConnectWithoutResourceInput[]
    upsert?: CraftInputUpsertWithWhereUniqueWithoutResourceInput | CraftInputUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: CraftInputCreateManyResourceInputEnvelope
    set?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    disconnect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    delete?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    update?: CraftInputUpdateWithWhereUniqueWithoutResourceInput | CraftInputUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: CraftInputUpdateManyWithWhereWithoutResourceInput | CraftInputUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: CraftInputScalarWhereInput | CraftInputScalarWhereInput[]
  }

  export type RecipeUncheckedUpdateManyWithoutOutputNestedInput = {
    create?: XOR<RecipeCreateWithoutOutputInput, RecipeUncheckedCreateWithoutOutputInput> | RecipeCreateWithoutOutputInput[] | RecipeUncheckedCreateWithoutOutputInput[]
    connectOrCreate?: RecipeCreateOrConnectWithoutOutputInput | RecipeCreateOrConnectWithoutOutputInput[]
    upsert?: RecipeUpsertWithWhereUniqueWithoutOutputInput | RecipeUpsertWithWhereUniqueWithoutOutputInput[]
    createMany?: RecipeCreateManyOutputInputEnvelope
    set?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    disconnect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    delete?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    connect?: RecipeWhereUniqueInput | RecipeWhereUniqueInput[]
    update?: RecipeUpdateWithWhereUniqueWithoutOutputInput | RecipeUpdateWithWhereUniqueWithoutOutputInput[]
    updateMany?: RecipeUpdateManyWithWhereWithoutOutputInput | RecipeUpdateManyWithWhereWithoutOutputInput[]
    deleteMany?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
  }

  export type PackItemUncheckedUpdateManyWithoutResourceNestedInput = {
    create?: XOR<PackItemCreateWithoutResourceInput, PackItemUncheckedCreateWithoutResourceInput> | PackItemCreateWithoutResourceInput[] | PackItemUncheckedCreateWithoutResourceInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutResourceInput | PackItemCreateOrConnectWithoutResourceInput[]
    upsert?: PackItemUpsertWithWhereUniqueWithoutResourceInput | PackItemUpsertWithWhereUniqueWithoutResourceInput[]
    createMany?: PackItemCreateManyResourceInputEnvelope
    set?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    disconnect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    delete?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    update?: PackItemUpdateWithWhereUniqueWithoutResourceInput | PackItemUpdateWithWhereUniqueWithoutResourceInput[]
    updateMany?: PackItemUpdateManyWithWhereWithoutResourceInput | PackItemUpdateManyWithWhereWithoutResourceInput[]
    deleteMany?: PackItemScalarWhereInput | PackItemScalarWhereInput[]
  }

  export type ResourceCreateNestedOneWithoutAsOutputInput = {
    create?: XOR<ResourceCreateWithoutAsOutputInput, ResourceUncheckedCreateWithoutAsOutputInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutAsOutputInput
    connect?: ResourceWhereUniqueInput
  }

  export type CraftInputCreateNestedManyWithoutRecipeInput = {
    create?: XOR<CraftInputCreateWithoutRecipeInput, CraftInputUncheckedCreateWithoutRecipeInput> | CraftInputCreateWithoutRecipeInput[] | CraftInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutRecipeInput | CraftInputCreateOrConnectWithoutRecipeInput[]
    createMany?: CraftInputCreateManyRecipeInputEnvelope
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
  }

  export type CraftInputUncheckedCreateNestedManyWithoutRecipeInput = {
    create?: XOR<CraftInputCreateWithoutRecipeInput, CraftInputUncheckedCreateWithoutRecipeInput> | CraftInputCreateWithoutRecipeInput[] | CraftInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutRecipeInput | CraftInputCreateOrConnectWithoutRecipeInput[]
    createMany?: CraftInputCreateManyRecipeInputEnvelope
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
  }

  export type ResourceUpdateOneRequiredWithoutAsOutputNestedInput = {
    create?: XOR<ResourceCreateWithoutAsOutputInput, ResourceUncheckedCreateWithoutAsOutputInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutAsOutputInput
    upsert?: ResourceUpsertWithoutAsOutputInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutAsOutputInput, ResourceUpdateWithoutAsOutputInput>, ResourceUncheckedUpdateWithoutAsOutputInput>
  }

  export type CraftInputUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<CraftInputCreateWithoutRecipeInput, CraftInputUncheckedCreateWithoutRecipeInput> | CraftInputCreateWithoutRecipeInput[] | CraftInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutRecipeInput | CraftInputCreateOrConnectWithoutRecipeInput[]
    upsert?: CraftInputUpsertWithWhereUniqueWithoutRecipeInput | CraftInputUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: CraftInputCreateManyRecipeInputEnvelope
    set?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    disconnect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    delete?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    update?: CraftInputUpdateWithWhereUniqueWithoutRecipeInput | CraftInputUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: CraftInputUpdateManyWithWhereWithoutRecipeInput | CraftInputUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: CraftInputScalarWhereInput | CraftInputScalarWhereInput[]
  }

  export type CraftInputUncheckedUpdateManyWithoutRecipeNestedInput = {
    create?: XOR<CraftInputCreateWithoutRecipeInput, CraftInputUncheckedCreateWithoutRecipeInput> | CraftInputCreateWithoutRecipeInput[] | CraftInputUncheckedCreateWithoutRecipeInput[]
    connectOrCreate?: CraftInputCreateOrConnectWithoutRecipeInput | CraftInputCreateOrConnectWithoutRecipeInput[]
    upsert?: CraftInputUpsertWithWhereUniqueWithoutRecipeInput | CraftInputUpsertWithWhereUniqueWithoutRecipeInput[]
    createMany?: CraftInputCreateManyRecipeInputEnvelope
    set?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    disconnect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    delete?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    connect?: CraftInputWhereUniqueInput | CraftInputWhereUniqueInput[]
    update?: CraftInputUpdateWithWhereUniqueWithoutRecipeInput | CraftInputUpdateWithWhereUniqueWithoutRecipeInput[]
    updateMany?: CraftInputUpdateManyWithWhereWithoutRecipeInput | CraftInputUpdateManyWithWhereWithoutRecipeInput[]
    deleteMany?: CraftInputScalarWhereInput | CraftInputScalarWhereInput[]
  }

  export type RecipeCreateNestedOneWithoutInputsInput = {
    create?: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInputsInput
    connect?: RecipeWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutAsInputInput = {
    create?: XOR<ResourceCreateWithoutAsInputInput, ResourceUncheckedCreateWithoutAsInputInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutAsInputInput
    connect?: ResourceWhereUniqueInput
  }

  export type RecipeUpdateOneRequiredWithoutInputsNestedInput = {
    create?: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
    connectOrCreate?: RecipeCreateOrConnectWithoutInputsInput
    upsert?: RecipeUpsertWithoutInputsInput
    connect?: RecipeWhereUniqueInput
    update?: XOR<XOR<RecipeUpdateToOneWithWhereWithoutInputsInput, RecipeUpdateWithoutInputsInput>, RecipeUncheckedUpdateWithoutInputsInput>
  }

  export type ResourceUpdateOneRequiredWithoutAsInputNestedInput = {
    create?: XOR<ResourceCreateWithoutAsInputInput, ResourceUncheckedCreateWithoutAsInputInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutAsInputInput
    upsert?: ResourceUpsertWithoutAsInputInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutAsInputInput, ResourceUpdateWithoutAsInputInput>, ResourceUncheckedUpdateWithoutAsInputInput>
  }

  export type CharacterCreateNestedOneWithoutPacksInput = {
    create?: XOR<CharacterCreateWithoutPacksInput, CharacterUncheckedCreateWithoutPacksInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutPacksInput
    connect?: CharacterWhereUniqueInput
  }

  export type PackItemCreateNestedManyWithoutPackInput = {
    create?: XOR<PackItemCreateWithoutPackInput, PackItemUncheckedCreateWithoutPackInput> | PackItemCreateWithoutPackInput[] | PackItemUncheckedCreateWithoutPackInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutPackInput | PackItemCreateOrConnectWithoutPackInput[]
    createMany?: PackItemCreateManyPackInputEnvelope
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
  }

  export type PackItemUncheckedCreateNestedManyWithoutPackInput = {
    create?: XOR<PackItemCreateWithoutPackInput, PackItemUncheckedCreateWithoutPackInput> | PackItemCreateWithoutPackInput[] | PackItemUncheckedCreateWithoutPackInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutPackInput | PackItemCreateOrConnectWithoutPackInput[]
    createMany?: PackItemCreateManyPackInputEnvelope
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
  }

  export type CharacterUpdateOneWithoutPacksNestedInput = {
    create?: XOR<CharacterCreateWithoutPacksInput, CharacterUncheckedCreateWithoutPacksInput>
    connectOrCreate?: CharacterCreateOrConnectWithoutPacksInput
    upsert?: CharacterUpsertWithoutPacksInput
    disconnect?: CharacterWhereInput | boolean
    delete?: CharacterWhereInput | boolean
    connect?: CharacterWhereUniqueInput
    update?: XOR<XOR<CharacterUpdateToOneWithWhereWithoutPacksInput, CharacterUpdateWithoutPacksInput>, CharacterUncheckedUpdateWithoutPacksInput>
  }

  export type PackItemUpdateManyWithoutPackNestedInput = {
    create?: XOR<PackItemCreateWithoutPackInput, PackItemUncheckedCreateWithoutPackInput> | PackItemCreateWithoutPackInput[] | PackItemUncheckedCreateWithoutPackInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutPackInput | PackItemCreateOrConnectWithoutPackInput[]
    upsert?: PackItemUpsertWithWhereUniqueWithoutPackInput | PackItemUpsertWithWhereUniqueWithoutPackInput[]
    createMany?: PackItemCreateManyPackInputEnvelope
    set?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    disconnect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    delete?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    update?: PackItemUpdateWithWhereUniqueWithoutPackInput | PackItemUpdateWithWhereUniqueWithoutPackInput[]
    updateMany?: PackItemUpdateManyWithWhereWithoutPackInput | PackItemUpdateManyWithWhereWithoutPackInput[]
    deleteMany?: PackItemScalarWhereInput | PackItemScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PackItemUncheckedUpdateManyWithoutPackNestedInput = {
    create?: XOR<PackItemCreateWithoutPackInput, PackItemUncheckedCreateWithoutPackInput> | PackItemCreateWithoutPackInput[] | PackItemUncheckedCreateWithoutPackInput[]
    connectOrCreate?: PackItemCreateOrConnectWithoutPackInput | PackItemCreateOrConnectWithoutPackInput[]
    upsert?: PackItemUpsertWithWhereUniqueWithoutPackInput | PackItemUpsertWithWhereUniqueWithoutPackInput[]
    createMany?: PackItemCreateManyPackInputEnvelope
    set?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    disconnect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    delete?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    connect?: PackItemWhereUniqueInput | PackItemWhereUniqueInput[]
    update?: PackItemUpdateWithWhereUniqueWithoutPackInput | PackItemUpdateWithWhereUniqueWithoutPackInput[]
    updateMany?: PackItemUpdateManyWithWhereWithoutPackInput | PackItemUpdateManyWithWhereWithoutPackInput[]
    deleteMany?: PackItemScalarWhereInput | PackItemScalarWhereInput[]
  }

  export type PackCreateNestedOneWithoutItemsInput = {
    create?: XOR<PackCreateWithoutItemsInput, PackUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PackCreateOrConnectWithoutItemsInput
    connect?: PackWhereUniqueInput
  }

  export type ResourceCreateNestedOneWithoutPackItemsInput = {
    create?: XOR<ResourceCreateWithoutPackItemsInput, ResourceUncheckedCreateWithoutPackItemsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutPackItemsInput
    connect?: ResourceWhereUniqueInput
  }

  export type PackUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PackCreateWithoutItemsInput, PackUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PackCreateOrConnectWithoutItemsInput
    upsert?: PackUpsertWithoutItemsInput
    connect?: PackWhereUniqueInput
    update?: XOR<XOR<PackUpdateToOneWithWhereWithoutItemsInput, PackUpdateWithoutItemsInput>, PackUncheckedUpdateWithoutItemsInput>
  }

  export type ResourceUpdateOneRequiredWithoutPackItemsNestedInput = {
    create?: XOR<ResourceCreateWithoutPackItemsInput, ResourceUncheckedCreateWithoutPackItemsInput>
    connectOrCreate?: ResourceCreateOrConnectWithoutPackItemsInput
    upsert?: ResourceUpsertWithoutPackItemsInput
    connect?: ResourceWhereUniqueInput
    update?: XOR<XOR<ResourceUpdateToOneWithWhereWithoutPackItemsInput, ResourceUpdateWithoutPackItemsInput>, ResourceUncheckedUpdateWithoutPackItemsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CharacterCreateWithoutAccountInput = {
    name: string
    class: string
    level: number
    server: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobCreateNestedManyWithoutCharacterInput
    packs?: PackCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutAccountInput = {
    id?: number
    name: string
    class: string
    level: number
    server: string
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutCharacterInput
    packs?: PackUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutAccountInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput>
  }

  export type CharacterCreateManyAccountInputEnvelope = {
    data: CharacterCreateManyAccountInput | CharacterCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithWhereUniqueWithoutAccountInput = {
    where: CharacterWhereUniqueInput
    update: XOR<CharacterUpdateWithoutAccountInput, CharacterUncheckedUpdateWithoutAccountInput>
    create: XOR<CharacterCreateWithoutAccountInput, CharacterUncheckedCreateWithoutAccountInput>
  }

  export type CharacterUpdateWithWhereUniqueWithoutAccountInput = {
    where: CharacterWhereUniqueInput
    data: XOR<CharacterUpdateWithoutAccountInput, CharacterUncheckedUpdateWithoutAccountInput>
  }

  export type CharacterUpdateManyWithWhereWithoutAccountInput = {
    where: CharacterScalarWhereInput
    data: XOR<CharacterUpdateManyMutationInput, CharacterUncheckedUpdateManyWithoutAccountInput>
  }

  export type CharacterScalarWhereInput = {
    AND?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    OR?: CharacterScalarWhereInput[]
    NOT?: CharacterScalarWhereInput | CharacterScalarWhereInput[]
    id?: IntFilter<"Character"> | number
    name?: StringFilter<"Character"> | string
    class?: StringFilter<"Character"> | string
    level?: IntFilter<"Character"> | number
    server?: StringFilter<"Character"> | string
    accountId?: IntFilter<"Character"> | number
    createdAt?: DateTimeFilter<"Character"> | Date | string
    updatedAt?: DateTimeFilter<"Character"> | Date | string
  }

  export type AccountCreateWithoutCharactersInput = {
    name: string
    email?: string | null
    password?: string | null
    isGoogle?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUncheckedCreateWithoutCharactersInput = {
    id?: number
    name: string
    email?: string | null
    password?: string | null
    isGoogle?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountCreateOrConnectWithoutCharactersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCharactersInput, AccountUncheckedCreateWithoutCharactersInput>
  }

  export type JobCreateWithoutCharacterInput = {
    name: string
    level?: number
    currentXP?: number
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: JobActivityCreateNestedManyWithoutJobInput
  }

  export type JobUncheckedCreateWithoutCharacterInput = {
    id?: number
    name: string
    level?: number
    currentXP?: number
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
    activities?: JobActivityUncheckedCreateNestedManyWithoutJobInput
  }

  export type JobCreateOrConnectWithoutCharacterInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutCharacterInput, JobUncheckedCreateWithoutCharacterInput>
  }

  export type JobCreateManyCharacterInputEnvelope = {
    data: JobCreateManyCharacterInput | JobCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type PackCreateWithoutCharacterInput = {
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PackItemCreateNestedManyWithoutPackInput
  }

  export type PackUncheckedCreateWithoutCharacterInput = {
    id?: number
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: PackItemUncheckedCreateNestedManyWithoutPackInput
  }

  export type PackCreateOrConnectWithoutCharacterInput = {
    where: PackWhereUniqueInput
    create: XOR<PackCreateWithoutCharacterInput, PackUncheckedCreateWithoutCharacterInput>
  }

  export type PackCreateManyCharacterInputEnvelope = {
    data: PackCreateManyCharacterInput | PackCreateManyCharacterInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutCharactersInput = {
    update: XOR<AccountUpdateWithoutCharactersInput, AccountUncheckedUpdateWithoutCharactersInput>
    create: XOR<AccountCreateWithoutCharactersInput, AccountUncheckedCreateWithoutCharactersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutCharactersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutCharactersInput, AccountUncheckedUpdateWithoutCharactersInput>
  }

  export type AccountUpdateWithoutCharactersInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isGoogle?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutCharactersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    isGoogle?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobUpsertWithWhereUniqueWithoutCharacterInput = {
    where: JobWhereUniqueInput
    update: XOR<JobUpdateWithoutCharacterInput, JobUncheckedUpdateWithoutCharacterInput>
    create: XOR<JobCreateWithoutCharacterInput, JobUncheckedCreateWithoutCharacterInput>
  }

  export type JobUpdateWithWhereUniqueWithoutCharacterInput = {
    where: JobWhereUniqueInput
    data: XOR<JobUpdateWithoutCharacterInput, JobUncheckedUpdateWithoutCharacterInput>
  }

  export type JobUpdateManyWithWhereWithoutCharacterInput = {
    where: JobScalarWhereInput
    data: XOR<JobUpdateManyMutationInput, JobUncheckedUpdateManyWithoutCharacterInput>
  }

  export type JobScalarWhereInput = {
    AND?: JobScalarWhereInput | JobScalarWhereInput[]
    OR?: JobScalarWhereInput[]
    NOT?: JobScalarWhereInput | JobScalarWhereInput[]
    id?: IntFilter<"Job"> | number
    name?: StringFilter<"Job"> | string
    level?: IntFilter<"Job"> | number
    currentXP?: IntFilter<"Job"> | number
    icon?: StringFilter<"Job"> | string
    characterId?: IntFilter<"Job"> | number
    createdAt?: DateTimeFilter<"Job"> | Date | string
    updatedAt?: DateTimeFilter<"Job"> | Date | string
  }

  export type PackUpsertWithWhereUniqueWithoutCharacterInput = {
    where: PackWhereUniqueInput
    update: XOR<PackUpdateWithoutCharacterInput, PackUncheckedUpdateWithoutCharacterInput>
    create: XOR<PackCreateWithoutCharacterInput, PackUncheckedCreateWithoutCharacterInput>
  }

  export type PackUpdateWithWhereUniqueWithoutCharacterInput = {
    where: PackWhereUniqueInput
    data: XOR<PackUpdateWithoutCharacterInput, PackUncheckedUpdateWithoutCharacterInput>
  }

  export type PackUpdateManyWithWhereWithoutCharacterInput = {
    where: PackScalarWhereInput
    data: XOR<PackUpdateManyMutationInput, PackUncheckedUpdateManyWithoutCharacterInput>
  }

  export type PackScalarWhereInput = {
    AND?: PackScalarWhereInput | PackScalarWhereInput[]
    OR?: PackScalarWhereInput[]
    NOT?: PackScalarWhereInput | PackScalarWhereInput[]
    id?: IntFilter<"Pack"> | number
    name?: StringFilter<"Pack"> | string
    description?: StringNullableFilter<"Pack"> | string | null
    jobType?: StringFilter<"Pack"> | string
    startLevel?: IntFilter<"Pack"> | number
    targetLevel?: IntFilter<"Pack"> | number
    isTemplate?: BoolFilter<"Pack"> | boolean
    characterId?: IntNullableFilter<"Pack"> | number | null
    createdAt?: DateTimeFilter<"Pack"> | Date | string
    updatedAt?: DateTimeFilter<"Pack"> | Date | string
  }

  export type CharacterCreateWithoutJobsInput = {
    name: string
    class: string
    level: number
    server: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCharactersInput
    packs?: PackCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutJobsInput = {
    id?: number
    name: string
    class: string
    level: number
    server: string
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    packs?: PackUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutJobsInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutJobsInput, CharacterUncheckedCreateWithoutJobsInput>
  }

  export type JobActivityCreateWithoutJobInput = {
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt?: Date | string
  }

  export type JobActivityUncheckedCreateWithoutJobInput = {
    id?: number
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt?: Date | string
  }

  export type JobActivityCreateOrConnectWithoutJobInput = {
    where: JobActivityWhereUniqueInput
    create: XOR<JobActivityCreateWithoutJobInput, JobActivityUncheckedCreateWithoutJobInput>
  }

  export type JobActivityCreateManyJobInputEnvelope = {
    data: JobActivityCreateManyJobInput | JobActivityCreateManyJobInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithoutJobsInput = {
    update: XOR<CharacterUpdateWithoutJobsInput, CharacterUncheckedUpdateWithoutJobsInput>
    create: XOR<CharacterCreateWithoutJobsInput, CharacterUncheckedCreateWithoutJobsInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutJobsInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutJobsInput, CharacterUncheckedUpdateWithoutJobsInput>
  }

  export type CharacterUpdateWithoutJobsInput = {
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCharactersNestedInput
    packs?: PackUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    packs?: PackUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type JobActivityUpsertWithWhereUniqueWithoutJobInput = {
    where: JobActivityWhereUniqueInput
    update: XOR<JobActivityUpdateWithoutJobInput, JobActivityUncheckedUpdateWithoutJobInput>
    create: XOR<JobActivityCreateWithoutJobInput, JobActivityUncheckedCreateWithoutJobInput>
  }

  export type JobActivityUpdateWithWhereUniqueWithoutJobInput = {
    where: JobActivityWhereUniqueInput
    data: XOR<JobActivityUpdateWithoutJobInput, JobActivityUncheckedUpdateWithoutJobInput>
  }

  export type JobActivityUpdateManyWithWhereWithoutJobInput = {
    where: JobActivityScalarWhereInput
    data: XOR<JobActivityUpdateManyMutationInput, JobActivityUncheckedUpdateManyWithoutJobInput>
  }

  export type JobActivityScalarWhereInput = {
    AND?: JobActivityScalarWhereInput | JobActivityScalarWhereInput[]
    OR?: JobActivityScalarWhereInput[]
    NOT?: JobActivityScalarWhereInput | JobActivityScalarWhereInput[]
    id?: IntFilter<"JobActivity"> | number
    jobId?: IntFilter<"JobActivity"> | number
    type?: StringFilter<"JobActivity"> | string
    itemId?: IntFilter<"JobActivity"> | number
    quantity?: IntFilter<"JobActivity"> | number
    xpGained?: IntFilter<"JobActivity"> | number
    createdAt?: DateTimeFilter<"JobActivity"> | Date | string
  }

  export type JobCreateWithoutActivitiesInput = {
    name: string
    level?: number
    currentXP?: number
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
    character: CharacterCreateNestedOneWithoutJobsInput
  }

  export type JobUncheckedCreateWithoutActivitiesInput = {
    id?: number
    name: string
    level?: number
    currentXP?: number
    icon: string
    characterId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobCreateOrConnectWithoutActivitiesInput = {
    where: JobWhereUniqueInput
    create: XOR<JobCreateWithoutActivitiesInput, JobUncheckedCreateWithoutActivitiesInput>
  }

  export type JobUpsertWithoutActivitiesInput = {
    update: XOR<JobUpdateWithoutActivitiesInput, JobUncheckedUpdateWithoutActivitiesInput>
    create: XOR<JobCreateWithoutActivitiesInput, JobUncheckedCreateWithoutActivitiesInput>
    where?: JobWhereInput
  }

  export type JobUpdateToOneWithWhereWithoutActivitiesInput = {
    where?: JobWhereInput
    data: XOR<JobUpdateWithoutActivitiesInput, JobUncheckedUpdateWithoutActivitiesInput>
  }

  export type JobUpdateWithoutActivitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneRequiredWithoutJobsNestedInput
  }

  export type JobUncheckedUpdateWithoutActivitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    characterId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftInputCreateWithoutResourceInput = {
    quantity: number
    recipe: RecipeCreateNestedOneWithoutInputsInput
  }

  export type CraftInputUncheckedCreateWithoutResourceInput = {
    id?: number
    recipeId: number
    quantity: number
  }

  export type CraftInputCreateOrConnectWithoutResourceInput = {
    where: CraftInputWhereUniqueInput
    create: XOR<CraftInputCreateWithoutResourceInput, CraftInputUncheckedCreateWithoutResourceInput>
  }

  export type CraftInputCreateManyResourceInputEnvelope = {
    data: CraftInputCreateManyResourceInput | CraftInputCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type RecipeCreateWithoutOutputInput = {
    name: string
    jobType: string
    level: number
    baseXP: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: CraftInputCreateNestedManyWithoutRecipeInput
  }

  export type RecipeUncheckedCreateWithoutOutputInput = {
    id?: number
    name: string
    jobType: string
    level: number
    baseXP: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    inputs?: CraftInputUncheckedCreateNestedManyWithoutRecipeInput
  }

  export type RecipeCreateOrConnectWithoutOutputInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutOutputInput, RecipeUncheckedCreateWithoutOutputInput>
  }

  export type RecipeCreateManyOutputInputEnvelope = {
    data: RecipeCreateManyOutputInput | RecipeCreateManyOutputInput[]
    skipDuplicates?: boolean
  }

  export type PackItemCreateWithoutResourceInput = {
    quantity: number
    obtained?: number
    pack: PackCreateNestedOneWithoutItemsInput
  }

  export type PackItemUncheckedCreateWithoutResourceInput = {
    id?: number
    packId: number
    quantity: number
    obtained?: number
  }

  export type PackItemCreateOrConnectWithoutResourceInput = {
    where: PackItemWhereUniqueInput
    create: XOR<PackItemCreateWithoutResourceInput, PackItemUncheckedCreateWithoutResourceInput>
  }

  export type PackItemCreateManyResourceInputEnvelope = {
    data: PackItemCreateManyResourceInput | PackItemCreateManyResourceInput[]
    skipDuplicates?: boolean
  }

  export type CraftInputUpsertWithWhereUniqueWithoutResourceInput = {
    where: CraftInputWhereUniqueInput
    update: XOR<CraftInputUpdateWithoutResourceInput, CraftInputUncheckedUpdateWithoutResourceInput>
    create: XOR<CraftInputCreateWithoutResourceInput, CraftInputUncheckedCreateWithoutResourceInput>
  }

  export type CraftInputUpdateWithWhereUniqueWithoutResourceInput = {
    where: CraftInputWhereUniqueInput
    data: XOR<CraftInputUpdateWithoutResourceInput, CraftInputUncheckedUpdateWithoutResourceInput>
  }

  export type CraftInputUpdateManyWithWhereWithoutResourceInput = {
    where: CraftInputScalarWhereInput
    data: XOR<CraftInputUpdateManyMutationInput, CraftInputUncheckedUpdateManyWithoutResourceInput>
  }

  export type CraftInputScalarWhereInput = {
    AND?: CraftInputScalarWhereInput | CraftInputScalarWhereInput[]
    OR?: CraftInputScalarWhereInput[]
    NOT?: CraftInputScalarWhereInput | CraftInputScalarWhereInput[]
    id?: IntFilter<"CraftInput"> | number
    recipeId?: IntFilter<"CraftInput"> | number
    resourceId?: IntFilter<"CraftInput"> | number
    quantity?: IntFilter<"CraftInput"> | number
  }

  export type RecipeUpsertWithWhereUniqueWithoutOutputInput = {
    where: RecipeWhereUniqueInput
    update: XOR<RecipeUpdateWithoutOutputInput, RecipeUncheckedUpdateWithoutOutputInput>
    create: XOR<RecipeCreateWithoutOutputInput, RecipeUncheckedCreateWithoutOutputInput>
  }

  export type RecipeUpdateWithWhereUniqueWithoutOutputInput = {
    where: RecipeWhereUniqueInput
    data: XOR<RecipeUpdateWithoutOutputInput, RecipeUncheckedUpdateWithoutOutputInput>
  }

  export type RecipeUpdateManyWithWhereWithoutOutputInput = {
    where: RecipeScalarWhereInput
    data: XOR<RecipeUpdateManyMutationInput, RecipeUncheckedUpdateManyWithoutOutputInput>
  }

  export type RecipeScalarWhereInput = {
    AND?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    OR?: RecipeScalarWhereInput[]
    NOT?: RecipeScalarWhereInput | RecipeScalarWhereInput[]
    id?: IntFilter<"Recipe"> | number
    name?: StringFilter<"Recipe"> | string
    jobType?: StringFilter<"Recipe"> | string
    level?: IntFilter<"Recipe"> | number
    baseXP?: IntFilter<"Recipe"> | number
    outputId?: IntFilter<"Recipe"> | number
    outputQty?: IntFilter<"Recipe"> | number
    createdAt?: DateTimeFilter<"Recipe"> | Date | string
    updatedAt?: DateTimeFilter<"Recipe"> | Date | string
  }

  export type PackItemUpsertWithWhereUniqueWithoutResourceInput = {
    where: PackItemWhereUniqueInput
    update: XOR<PackItemUpdateWithoutResourceInput, PackItemUncheckedUpdateWithoutResourceInput>
    create: XOR<PackItemCreateWithoutResourceInput, PackItemUncheckedCreateWithoutResourceInput>
  }

  export type PackItemUpdateWithWhereUniqueWithoutResourceInput = {
    where: PackItemWhereUniqueInput
    data: XOR<PackItemUpdateWithoutResourceInput, PackItemUncheckedUpdateWithoutResourceInput>
  }

  export type PackItemUpdateManyWithWhereWithoutResourceInput = {
    where: PackItemScalarWhereInput
    data: XOR<PackItemUpdateManyMutationInput, PackItemUncheckedUpdateManyWithoutResourceInput>
  }

  export type PackItemScalarWhereInput = {
    AND?: PackItemScalarWhereInput | PackItemScalarWhereInput[]
    OR?: PackItemScalarWhereInput[]
    NOT?: PackItemScalarWhereInput | PackItemScalarWhereInput[]
    id?: IntFilter<"PackItem"> | number
    packId?: IntFilter<"PackItem"> | number
    resourceId?: IntFilter<"PackItem"> | number
    quantity?: IntFilter<"PackItem"> | number
    obtained?: IntFilter<"PackItem"> | number
  }

  export type ResourceCreateWithoutAsOutputInput = {
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asInput?: CraftInputCreateNestedManyWithoutResourceInput
    packItems?: PackItemCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutAsOutputInput = {
    id?: number
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asInput?: CraftInputUncheckedCreateNestedManyWithoutResourceInput
    packItems?: PackItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutAsOutputInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutAsOutputInput, ResourceUncheckedCreateWithoutAsOutputInput>
  }

  export type CraftInputCreateWithoutRecipeInput = {
    quantity: number
    resource: ResourceCreateNestedOneWithoutAsInputInput
  }

  export type CraftInputUncheckedCreateWithoutRecipeInput = {
    id?: number
    resourceId: number
    quantity: number
  }

  export type CraftInputCreateOrConnectWithoutRecipeInput = {
    where: CraftInputWhereUniqueInput
    create: XOR<CraftInputCreateWithoutRecipeInput, CraftInputUncheckedCreateWithoutRecipeInput>
  }

  export type CraftInputCreateManyRecipeInputEnvelope = {
    data: CraftInputCreateManyRecipeInput | CraftInputCreateManyRecipeInput[]
    skipDuplicates?: boolean
  }

  export type ResourceUpsertWithoutAsOutputInput = {
    update: XOR<ResourceUpdateWithoutAsOutputInput, ResourceUncheckedUpdateWithoutAsOutputInput>
    create: XOR<ResourceCreateWithoutAsOutputInput, ResourceUncheckedCreateWithoutAsOutputInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutAsOutputInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutAsOutputInput, ResourceUncheckedUpdateWithoutAsOutputInput>
  }

  export type ResourceUpdateWithoutAsOutputInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asInput?: CraftInputUpdateManyWithoutResourceNestedInput
    packItems?: PackItemUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutAsOutputInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asInput?: CraftInputUncheckedUpdateManyWithoutResourceNestedInput
    packItems?: PackItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type CraftInputUpsertWithWhereUniqueWithoutRecipeInput = {
    where: CraftInputWhereUniqueInput
    update: XOR<CraftInputUpdateWithoutRecipeInput, CraftInputUncheckedUpdateWithoutRecipeInput>
    create: XOR<CraftInputCreateWithoutRecipeInput, CraftInputUncheckedCreateWithoutRecipeInput>
  }

  export type CraftInputUpdateWithWhereUniqueWithoutRecipeInput = {
    where: CraftInputWhereUniqueInput
    data: XOR<CraftInputUpdateWithoutRecipeInput, CraftInputUncheckedUpdateWithoutRecipeInput>
  }

  export type CraftInputUpdateManyWithWhereWithoutRecipeInput = {
    where: CraftInputScalarWhereInput
    data: XOR<CraftInputUpdateManyMutationInput, CraftInputUncheckedUpdateManyWithoutRecipeInput>
  }

  export type RecipeCreateWithoutInputsInput = {
    name: string
    jobType: string
    level: number
    baseXP: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
    output: ResourceCreateNestedOneWithoutAsOutputInput
  }

  export type RecipeUncheckedCreateWithoutInputsInput = {
    id?: number
    name: string
    jobType: string
    level: number
    baseXP: number
    outputId: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RecipeCreateOrConnectWithoutInputsInput = {
    where: RecipeWhereUniqueInput
    create: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
  }

  export type ResourceCreateWithoutAsInputInput = {
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asOutput?: RecipeCreateNestedManyWithoutOutputInput
    packItems?: PackItemCreateNestedManyWithoutResourceInput
  }

  export type ResourceUncheckedCreateWithoutAsInputInput = {
    id?: number
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asOutput?: RecipeUncheckedCreateNestedManyWithoutOutputInput
    packItems?: PackItemUncheckedCreateNestedManyWithoutResourceInput
  }

  export type ResourceCreateOrConnectWithoutAsInputInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutAsInputInput, ResourceUncheckedCreateWithoutAsInputInput>
  }

  export type RecipeUpsertWithoutInputsInput = {
    update: XOR<RecipeUpdateWithoutInputsInput, RecipeUncheckedUpdateWithoutInputsInput>
    create: XOR<RecipeCreateWithoutInputsInput, RecipeUncheckedCreateWithoutInputsInput>
    where?: RecipeWhereInput
  }

  export type RecipeUpdateToOneWithWhereWithoutInputsInput = {
    where?: RecipeWhereInput
    data: XOR<RecipeUpdateWithoutInputsInput, RecipeUncheckedUpdateWithoutInputsInput>
  }

  export type RecipeUpdateWithoutInputsInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    output?: ResourceUpdateOneRequiredWithoutAsOutputNestedInput
  }

  export type RecipeUncheckedUpdateWithoutInputsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputId?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpsertWithoutAsInputInput = {
    update: XOR<ResourceUpdateWithoutAsInputInput, ResourceUncheckedUpdateWithoutAsInputInput>
    create: XOR<ResourceCreateWithoutAsInputInput, ResourceUncheckedCreateWithoutAsInputInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutAsInputInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutAsInputInput, ResourceUncheckedUpdateWithoutAsInputInput>
  }

  export type ResourceUpdateWithoutAsInputInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asOutput?: RecipeUpdateManyWithoutOutputNestedInput
    packItems?: PackItemUpdateManyWithoutResourceNestedInput
  }

  export type ResourceUncheckedUpdateWithoutAsInputInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asOutput?: RecipeUncheckedUpdateManyWithoutOutputNestedInput
    packItems?: PackItemUncheckedUpdateManyWithoutResourceNestedInput
  }

  export type CharacterCreateWithoutPacksInput = {
    name: string
    class: string
    level: number
    server: string
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutCharactersInput
    jobs?: JobCreateNestedManyWithoutCharacterInput
  }

  export type CharacterUncheckedCreateWithoutPacksInput = {
    id?: number
    name: string
    class: string
    level: number
    server: string
    accountId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: JobUncheckedCreateNestedManyWithoutCharacterInput
  }

  export type CharacterCreateOrConnectWithoutPacksInput = {
    where: CharacterWhereUniqueInput
    create: XOR<CharacterCreateWithoutPacksInput, CharacterUncheckedCreateWithoutPacksInput>
  }

  export type PackItemCreateWithoutPackInput = {
    quantity: number
    obtained?: number
    resource: ResourceCreateNestedOneWithoutPackItemsInput
  }

  export type PackItemUncheckedCreateWithoutPackInput = {
    id?: number
    resourceId: number
    quantity: number
    obtained?: number
  }

  export type PackItemCreateOrConnectWithoutPackInput = {
    where: PackItemWhereUniqueInput
    create: XOR<PackItemCreateWithoutPackInput, PackItemUncheckedCreateWithoutPackInput>
  }

  export type PackItemCreateManyPackInputEnvelope = {
    data: PackItemCreateManyPackInput | PackItemCreateManyPackInput[]
    skipDuplicates?: boolean
  }

  export type CharacterUpsertWithoutPacksInput = {
    update: XOR<CharacterUpdateWithoutPacksInput, CharacterUncheckedUpdateWithoutPacksInput>
    create: XOR<CharacterCreateWithoutPacksInput, CharacterUncheckedCreateWithoutPacksInput>
    where?: CharacterWhereInput
  }

  export type CharacterUpdateToOneWithWhereWithoutPacksInput = {
    where?: CharacterWhereInput
    data: XOR<CharacterUpdateWithoutPacksInput, CharacterUncheckedUpdateWithoutPacksInput>
  }

  export type CharacterUpdateWithoutPacksInput = {
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutCharactersNestedInput
    jobs?: JobUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutPacksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    accountId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type PackItemUpsertWithWhereUniqueWithoutPackInput = {
    where: PackItemWhereUniqueInput
    update: XOR<PackItemUpdateWithoutPackInput, PackItemUncheckedUpdateWithoutPackInput>
    create: XOR<PackItemCreateWithoutPackInput, PackItemUncheckedCreateWithoutPackInput>
  }

  export type PackItemUpdateWithWhereUniqueWithoutPackInput = {
    where: PackItemWhereUniqueInput
    data: XOR<PackItemUpdateWithoutPackInput, PackItemUncheckedUpdateWithoutPackInput>
  }

  export type PackItemUpdateManyWithWhereWithoutPackInput = {
    where: PackItemScalarWhereInput
    data: XOR<PackItemUpdateManyMutationInput, PackItemUncheckedUpdateManyWithoutPackInput>
  }

  export type PackCreateWithoutItemsInput = {
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    character?: CharacterCreateNestedOneWithoutPacksInput
  }

  export type PackUncheckedCreateWithoutItemsInput = {
    id?: number
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    characterId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackCreateOrConnectWithoutItemsInput = {
    where: PackWhereUniqueInput
    create: XOR<PackCreateWithoutItemsInput, PackUncheckedCreateWithoutItemsInput>
  }

  export type ResourceCreateWithoutPackItemsInput = {
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asInput?: CraftInputCreateNestedManyWithoutResourceInput
    asOutput?: RecipeCreateNestedManyWithoutOutputInput
  }

  export type ResourceUncheckedCreateWithoutPackItemsInput = {
    id?: number
    name: string
    type: string
    jobType: string
    level: number
    baseXP: number
    icon: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    asInput?: CraftInputUncheckedCreateNestedManyWithoutResourceInput
    asOutput?: RecipeUncheckedCreateNestedManyWithoutOutputInput
  }

  export type ResourceCreateOrConnectWithoutPackItemsInput = {
    where: ResourceWhereUniqueInput
    create: XOR<ResourceCreateWithoutPackItemsInput, ResourceUncheckedCreateWithoutPackItemsInput>
  }

  export type PackUpsertWithoutItemsInput = {
    update: XOR<PackUpdateWithoutItemsInput, PackUncheckedUpdateWithoutItemsInput>
    create: XOR<PackCreateWithoutItemsInput, PackUncheckedCreateWithoutItemsInput>
    where?: PackWhereInput
  }

  export type PackUpdateToOneWithWhereWithoutItemsInput = {
    where?: PackWhereInput
    data: XOR<PackUpdateWithoutItemsInput, PackUncheckedUpdateWithoutItemsInput>
  }

  export type PackUpdateWithoutItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    character?: CharacterUpdateOneWithoutPacksNestedInput
  }

  export type PackUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    characterId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ResourceUpsertWithoutPackItemsInput = {
    update: XOR<ResourceUpdateWithoutPackItemsInput, ResourceUncheckedUpdateWithoutPackItemsInput>
    create: XOR<ResourceCreateWithoutPackItemsInput, ResourceUncheckedCreateWithoutPackItemsInput>
    where?: ResourceWhereInput
  }

  export type ResourceUpdateToOneWithWhereWithoutPackItemsInput = {
    where?: ResourceWhereInput
    data: XOR<ResourceUpdateWithoutPackItemsInput, ResourceUncheckedUpdateWithoutPackItemsInput>
  }

  export type ResourceUpdateWithoutPackItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asInput?: CraftInputUpdateManyWithoutResourceNestedInput
    asOutput?: RecipeUpdateManyWithoutOutputNestedInput
  }

  export type ResourceUncheckedUpdateWithoutPackItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    asInput?: CraftInputUncheckedUpdateManyWithoutResourceNestedInput
    asOutput?: RecipeUncheckedUpdateManyWithoutOutputNestedInput
  }

  export type CharacterCreateManyAccountInput = {
    id?: number
    name: string
    class: string
    level: number
    server: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CharacterUpdateWithoutAccountInput = {
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUpdateManyWithoutCharacterNestedInput
    packs?: PackUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: JobUncheckedUpdateManyWithoutCharacterNestedInput
    packs?: PackUncheckedUpdateManyWithoutCharacterNestedInput
  }

  export type CharacterUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    class?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    server?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobCreateManyCharacterInput = {
    id?: number
    name: string
    level?: number
    currentXP?: number
    icon: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackCreateManyCharacterInput = {
    id?: number
    name: string
    description?: string | null
    jobType: string
    startLevel: number
    targetLevel: number
    isTemplate?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JobUpdateWithoutCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: JobActivityUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    activities?: JobActivityUncheckedUpdateManyWithoutJobNestedInput
  }

  export type JobUncheckedUpdateManyWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    currentXP?: IntFieldUpdateOperationsInput | number
    icon?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackUpdateWithoutCharacterInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PackItemUpdateManyWithoutPackNestedInput
  }

  export type PackUncheckedUpdateWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: PackItemUncheckedUpdateManyWithoutPackNestedInput
  }

  export type PackUncheckedUpdateManyWithoutCharacterInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobType?: StringFieldUpdateOperationsInput | string
    startLevel?: IntFieldUpdateOperationsInput | number
    targetLevel?: IntFieldUpdateOperationsInput | number
    isTemplate?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobActivityCreateManyJobInput = {
    id?: number
    type: string
    itemId: number
    quantity: number
    xpGained: number
    createdAt?: Date | string
  }

  export type JobActivityUpdateWithoutJobInput = {
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobActivityUncheckedUpdateWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JobActivityUncheckedUpdateManyWithoutJobInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    itemId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    xpGained?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CraftInputCreateManyResourceInput = {
    id?: number
    recipeId: number
    quantity: number
  }

  export type RecipeCreateManyOutputInput = {
    id?: number
    name: string
    jobType: string
    level: number
    baseXP: number
    outputQty: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PackItemCreateManyResourceInput = {
    id?: number
    packId: number
    quantity: number
    obtained?: number
  }

  export type CraftInputUpdateWithoutResourceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    recipe?: RecipeUpdateOneRequiredWithoutInputsNestedInput
  }

  export type CraftInputUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CraftInputUncheckedUpdateManyWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    recipeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type RecipeUpdateWithoutOutputInput = {
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: CraftInputUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateWithoutOutputInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inputs?: CraftInputUncheckedUpdateManyWithoutRecipeNestedInput
  }

  export type RecipeUncheckedUpdateManyWithoutOutputInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    jobType?: StringFieldUpdateOperationsInput | string
    level?: IntFieldUpdateOperationsInput | number
    baseXP?: IntFieldUpdateOperationsInput | number
    outputQty?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PackItemUpdateWithoutResourceInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
    pack?: PackUpdateOneRequiredWithoutItemsNestedInput
  }

  export type PackItemUncheckedUpdateWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    packId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }

  export type PackItemUncheckedUpdateManyWithoutResourceInput = {
    id?: IntFieldUpdateOperationsInput | number
    packId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }

  export type CraftInputCreateManyRecipeInput = {
    id?: number
    resourceId: number
    quantity: number
  }

  export type CraftInputUpdateWithoutRecipeInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    resource?: ResourceUpdateOneRequiredWithoutAsInputNestedInput
  }

  export type CraftInputUncheckedUpdateWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type CraftInputUncheckedUpdateManyWithoutRecipeInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type PackItemCreateManyPackInput = {
    id?: number
    resourceId: number
    quantity: number
    obtained?: number
  }

  export type PackItemUpdateWithoutPackInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
    resource?: ResourceUpdateOneRequiredWithoutPackItemsNestedInput
  }

  export type PackItemUncheckedUpdateWithoutPackInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }

  export type PackItemUncheckedUpdateManyWithoutPackInput = {
    id?: IntFieldUpdateOperationsInput | number
    resourceId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    obtained?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterCountOutputTypeDefaultArgs instead
     */
    export type CharacterCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobCountOutputTypeDefaultArgs instead
     */
    export type JobCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceCountOutputTypeDefaultArgs instead
     */
    export type ResourceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeCountOutputTypeDefaultArgs instead
     */
    export type RecipeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackCountOutputTypeDefaultArgs instead
     */
    export type PackCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CharacterDefaultArgs instead
     */
    export type CharacterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CharacterDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobDefaultArgs instead
     */
    export type JobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JobActivityDefaultArgs instead
     */
    export type JobActivityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JobActivityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResourceDefaultArgs instead
     */
    export type ResourceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResourceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RecipeDefaultArgs instead
     */
    export type RecipeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RecipeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CraftInputDefaultArgs instead
     */
    export type CraftInputArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CraftInputDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackDefaultArgs instead
     */
    export type PackArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PackItemDefaultArgs instead
     */
    export type PackItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PackItemDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}